{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yona is a minimalistic , (strongly) dynamically typed, parallel and non-blocking , polyglot , strict , functional programming language, with ML -like syntax, for the GraalVM virtual machine (VM). Yona puts a strong focus on code readability. Yona abstract users from dealing with non-blocking asynchronous computations and parallelism. While these features are commonly available in other languages nowadays, they are almost exclusively non-native solutions that come in forms of libraries or frameworks and are difficult to integrate with existing codebases. On top of that, dealing with these additional libraries requires a conscious effort of the programmer to choose/learn/integrate these libraries into their mindset when writing new code. Release Notes Blog Goals & Priorities \u00b6 Excellent readability - simple syntax, few keywords, virtually no boilerplate. Few types of expressions - module , import , function(function does not need a keyword, it is defined by a name and arguments - patterns), case , if , let , do , with and try / catch + raise . Simple module system - ability to expose functions for use in other modules, and ability to import them from other modules. Modules are first level values and can be created dynamically. Single expression principle - program is always one expression - this enables simpler evaluation and syntax, allows writing simple scripts as well as complex applications. Powerful and efficient built-in immutable data structures with full support for pattern matching , including Sequence, Dictionary and Set. Custom data types re presentable as records . Built-in runtime level non-blocking asynchronous IO . Simple concurrency , built-into runtime, no need for any abstractions such as Futures, Channels or Actors. Advanced concurrency provided by built-in Software Transactions Memory (STM) module. Polyglot language - interoperability with other languages via GraalVM. Powerful resource management - automatically manage resources using built-in context manager infrastructure. Tip Read more about the philosophy behind Yona here . Status \u00b6 The Yona language is currently in active development. The release plan is: May 25 th 2020. The focus of this release was: stabilized syntax, semantics, and runtime automated the release process establish website and documentation spread the word and allow users to \"play\" with the language and the interpreter collect some feedback from interested users 2021/Q4. Focus of this release is: finished STM implementation resource management: with expression regular expressions Intellij plugin significantly grow the standard library focus on optimizations in the interpreter final - 2022. Focus of this release is: stabilize standard library focus on tooling, such as package management, editor/IDE support provide a high-quality REPL","title":"Yona Language"},{"location":"#goals-priorities","text":"Excellent readability - simple syntax, few keywords, virtually no boilerplate. Few types of expressions - module , import , function(function does not need a keyword, it is defined by a name and arguments - patterns), case , if , let , do , with and try / catch + raise . Simple module system - ability to expose functions for use in other modules, and ability to import them from other modules. Modules are first level values and can be created dynamically. Single expression principle - program is always one expression - this enables simpler evaluation and syntax, allows writing simple scripts as well as complex applications. Powerful and efficient built-in immutable data structures with full support for pattern matching , including Sequence, Dictionary and Set. Custom data types re presentable as records . Built-in runtime level non-blocking asynchronous IO . Simple concurrency , built-into runtime, no need for any abstractions such as Futures, Channels or Actors. Advanced concurrency provided by built-in Software Transactions Memory (STM) module. Polyglot language - interoperability with other languages via GraalVM. Powerful resource management - automatically manage resources using built-in context manager infrastructure. Tip Read more about the philosophy behind Yona here .","title":"Goals &amp; Priorities"},{"location":"#status","text":"The Yona language is currently in active development. The release plan is: May 25 th 2020. The focus of this release was: stabilized syntax, semantics, and runtime automated the release process establish website and documentation spread the word and allow users to \"play\" with the language and the interpreter collect some feedback from interested users 2021/Q4. Focus of this release is: finished STM implementation resource management: with expression regular expressions Intellij plugin significantly grow the standard library focus on optimizations in the interpreter final - 2022. Focus of this release is: stabilize standard library focus on tooling, such as package management, editor/IDE support provide a high-quality REPL","title":"Status"},{"location":"about/","text":"Philosophy \u00b6 For those familiar with other functional programming languages, such as Lisp, Haskell or Erlang, most of the concepts mentioned in this documentation are not totally alien. This section would nevertheless focus on why particular features are present in Yona while others are not. For readers more familiar with other paradigms, such as object oriented or imperative programming, this section should be about eliminating some concerns users of these languages might have. Yona does not support imperative programming , as that requires explicit control flow and state manipulation. An example for that is a loop with a counter, that gets increased at each step. Yona does not have variables that could be modified, nor does it have \"loops\" in the imperative sense. Instead recursion or generators may be used for iteration. When it comes to object oriented features, it's important to separate two things. One is that most common feature of object oriented languages, encapsulation, in the traditional sense is about hiding mutable state. As previously stated, Yona doesn't have mutable state, so hiding it in an object doesn't provide much of a value. Yona is a lexically scoped language though and fully supports hiding internal implementation details either via scoping expressions ( let , do or case ), or using closures as well (lambdas). This means that a particular alias or a name is only available within the scope in which it is defined. Moreover, modules allow user to expose only certain functions, and not others. This is a form of interface concept, as it is known in the object oriented world. Polymorophism can take various shapes in Yona. First obvious option that comes to mind, is using pattern matching. A function can be defined for different patterns and in that way replicate polymorphic methods from object oriented languages. Another possibility could be having multiple modules defined, with the same interface (exposed functions) and switch them dynamically based on any arbitrary conditions the user needs. There is a lot of flexibility in Yona due to its dynamic nature. When it comes to statically typed functional languages, such as Haskell or Elm, one might wonder about things like purity, type classes or Algebraic Data Types (ADTs). Yona is not a pure language, in the sense that it does not enforce separation of side effects and pure computations (side-effect free). Side effects represent operations modifying an external state, for example some kind of a global state, input/output, etc. Type classes have no real counterpart in Yona since Yona is dynamically typed. What would otherwise be achieved using type classes, would have to be achieved by a convention of sorts in Yona, for example that there would be an expectation of certain modules to export certain interface. ADTs in Yona do not need to be defined upfront, as there is no compilation phase to check their validity or perform exhaustivness checks (where a compiler ensures that all possible cases are being tested in a case expression). That doesn't mean that ADTs cannot be modeled in Yona, they can, they just won't have a static type check performed on them before running the program. They may be represented using symbols , tuples or records , or any combination of those. Execution Model \u00b6 Yona provides fully transparent runtime system that integrates asynchronous non-blocking IO features with concurrent execution of the code. This means, there is no special syntax or special data types representing asynchronous computations. Everything related to non-blocking IO is hidden within the runtime and exposed via the standard library, and all expressions consisting of asynchronous expressions(an asynchronous expression is usually obtained from the standard library or created by function async ) are evaluated in asynchronous, non-blocking matter. This approach provides several benefits to languages as opposed to having these features provided via external libaries, mainly that such library would have to be adopted by other libraries/frameworks in order to be usable and it would still impose additional boilerplate simply because libraries cannot typically change language syntax/semantics. This is why Yona provides these features from day one, built into language syntax and semantics and therefore it is always available to any program without any external dependencies. At the same time, putting these features directly on the language/runtime level allows for additional optimizations that could otherwise be tricky or impossible. Example \u00b6 Following example will be used as a case study into Yona's execution model. Note that this example code actually will not work from Yona 0.8.1 , because of the resource management feature, but it is still a good example for understanding the underlying evaluation model. Make sure to read the next section after this one to see how this program needs to be written in more recent Yona versions. The same properties of the evaluation still apply! let keys_file = File :: open \"tests/Keys.txt\" { : read } values_file = File :: open \"tests/Values.txt\" { : read } keys = File :: read_lines keys_file values = File :: read_lines values_file () = File :: close keys_file () = File :: close values_file in Seq :: zip keys values |> Dict :: from_seq In this example, both files are read concurrently, without having to write any additional boiler-plate. How does Yona do this? A couple of things: first, check the difference between the do and let expressions on the syntax page. They both are used to evaluate multiple steps of computation, however do ensures that the steps take place in the same sequence as they are defined, let tries to parallelize non-blocking tasks. Yona will first perform a static analysis of the let expression in order to determine dependencies between aliases/steps . It knows that keys_file and values_file are used in the File::read_lines function and also knows that keys and values do not depend on each other , and so they may be ran concurrently . Yona doesn't parallelize keys_file and values_file , nor does it parallelize closing files - even though it seemingly should - there are no dependencies between these lines either. The trick is that File::read_lines is a function that returns a runtime level Promise (hidden from the user), and that means that reading two files in parallel is actually fine, since otherwise Yona would need to block the execution there, so it can just block on both being read at once. Another important concept here is that the order of aliases defined in the let expression does matter . Yona doesn't just randomly re-arrange them based on dependencies alone. If it did, it could for example close those files before they are ever read. That would be incorrect. Yona just uses static analysis of this expression to determine which aliases can be \"batched\" and actually batches the execution if they provide underlying Promises. Then the whole expression is transformed into something like this: Execute batch 1 (sequentially, since File::open does not return a Promise): keys_file = File :: open \"tests/Keys.txt\" { : read } values_file = File :: open \"tests/Values.txt\" { : read } Execute batch 2 (in parallel, since File::read_lines does return a Promise): keys = File :: read_lines keys_file values = File :: read_lines values_file Result from batch 2 is a Promise aggregating both keys and values, which when complete, executes batch 3: () = File :: close keys_file () = File :: close values_file Finally, the whole let expression is now a Promise, so run the final expression whenever it is ready: Seq :: zip keys values |> Dict :: from_seq |> IO :: println Yona automatically chains runtime Promises as needed and, more than that, it \"unwraps\" them whenever they are complete, so the runtime doesn't actually get bloated with propagating Promises all over the place. As soon as a Promise is computed, it becomes just a regular value again. These concepts allows programmers to focus on expressing concurrent programs much more easily and not having to deal with the details of the actual execution order. Additionally, when code must be executed sequentially, without explicit dependencies, a special expression do is available. Simplifying the example by using resource managemenet \u00b6 This example that concurrenly reads two files, line by line, and produces pairs of them as a dictionary can be implemented in Yona using its resource management features, as of Yona 0.8.1. Shorter version, equivalent in terms of features, but actually properly handling errors would look like: let keys = with File :: open \"tests/Keys.txt\" { : read } as keys_file File :: read_lines keys_file end values = with File :: open \"tests/Values.txt\" { : read } as values_file File :: read_lines values_file end in Seq :: zip keys values |> Dict :: from_seq Note that if error arises in the original example, files would not be closed. In this improved example they would. Otherwise, everything else regarding the non-blocking and parallel nature of this code stands. Implementation \u00b6 In terms of implementation, the runtime system of Yona can be viewed in terms of promise pipelineing or call-streams. The difference is that this pipelining and promise abstraction as such is completely transparent to the programmer and exists solely on the runtime level. Evaluation \u00b6 Evaluation of an Yona program consists of evaluating a single expression. This is important, because everything, including module definitions are simple expressions in Yona. Module loader then takes advantage of this principle, knowing that an imported module will be a file defining a module expression. It can simply evaluate it and retrieve the module itself.","title":"About Yona"},{"location":"about/#philosophy","text":"For those familiar with other functional programming languages, such as Lisp, Haskell or Erlang, most of the concepts mentioned in this documentation are not totally alien. This section would nevertheless focus on why particular features are present in Yona while others are not. For readers more familiar with other paradigms, such as object oriented or imperative programming, this section should be about eliminating some concerns users of these languages might have. Yona does not support imperative programming , as that requires explicit control flow and state manipulation. An example for that is a loop with a counter, that gets increased at each step. Yona does not have variables that could be modified, nor does it have \"loops\" in the imperative sense. Instead recursion or generators may be used for iteration. When it comes to object oriented features, it's important to separate two things. One is that most common feature of object oriented languages, encapsulation, in the traditional sense is about hiding mutable state. As previously stated, Yona doesn't have mutable state, so hiding it in an object doesn't provide much of a value. Yona is a lexically scoped language though and fully supports hiding internal implementation details either via scoping expressions ( let , do or case ), or using closures as well (lambdas). This means that a particular alias or a name is only available within the scope in which it is defined. Moreover, modules allow user to expose only certain functions, and not others. This is a form of interface concept, as it is known in the object oriented world. Polymorophism can take various shapes in Yona. First obvious option that comes to mind, is using pattern matching. A function can be defined for different patterns and in that way replicate polymorphic methods from object oriented languages. Another possibility could be having multiple modules defined, with the same interface (exposed functions) and switch them dynamically based on any arbitrary conditions the user needs. There is a lot of flexibility in Yona due to its dynamic nature. When it comes to statically typed functional languages, such as Haskell or Elm, one might wonder about things like purity, type classes or Algebraic Data Types (ADTs). Yona is not a pure language, in the sense that it does not enforce separation of side effects and pure computations (side-effect free). Side effects represent operations modifying an external state, for example some kind of a global state, input/output, etc. Type classes have no real counterpart in Yona since Yona is dynamically typed. What would otherwise be achieved using type classes, would have to be achieved by a convention of sorts in Yona, for example that there would be an expectation of certain modules to export certain interface. ADTs in Yona do not need to be defined upfront, as there is no compilation phase to check their validity or perform exhaustivness checks (where a compiler ensures that all possible cases are being tested in a case expression). That doesn't mean that ADTs cannot be modeled in Yona, they can, they just won't have a static type check performed on them before running the program. They may be represented using symbols , tuples or records , or any combination of those.","title":"Philosophy"},{"location":"about/#execution-model","text":"Yona provides fully transparent runtime system that integrates asynchronous non-blocking IO features with concurrent execution of the code. This means, there is no special syntax or special data types representing asynchronous computations. Everything related to non-blocking IO is hidden within the runtime and exposed via the standard library, and all expressions consisting of asynchronous expressions(an asynchronous expression is usually obtained from the standard library or created by function async ) are evaluated in asynchronous, non-blocking matter. This approach provides several benefits to languages as opposed to having these features provided via external libaries, mainly that such library would have to be adopted by other libraries/frameworks in order to be usable and it would still impose additional boilerplate simply because libraries cannot typically change language syntax/semantics. This is why Yona provides these features from day one, built into language syntax and semantics and therefore it is always available to any program without any external dependencies. At the same time, putting these features directly on the language/runtime level allows for additional optimizations that could otherwise be tricky or impossible.","title":"Execution Model"},{"location":"about/#example","text":"Following example will be used as a case study into Yona's execution model. Note that this example code actually will not work from Yona 0.8.1 , because of the resource management feature, but it is still a good example for understanding the underlying evaluation model. Make sure to read the next section after this one to see how this program needs to be written in more recent Yona versions. The same properties of the evaluation still apply! let keys_file = File :: open \"tests/Keys.txt\" { : read } values_file = File :: open \"tests/Values.txt\" { : read } keys = File :: read_lines keys_file values = File :: read_lines values_file () = File :: close keys_file () = File :: close values_file in Seq :: zip keys values |> Dict :: from_seq In this example, both files are read concurrently, without having to write any additional boiler-plate. How does Yona do this? A couple of things: first, check the difference between the do and let expressions on the syntax page. They both are used to evaluate multiple steps of computation, however do ensures that the steps take place in the same sequence as they are defined, let tries to parallelize non-blocking tasks. Yona will first perform a static analysis of the let expression in order to determine dependencies between aliases/steps . It knows that keys_file and values_file are used in the File::read_lines function and also knows that keys and values do not depend on each other , and so they may be ran concurrently . Yona doesn't parallelize keys_file and values_file , nor does it parallelize closing files - even though it seemingly should - there are no dependencies between these lines either. The trick is that File::read_lines is a function that returns a runtime level Promise (hidden from the user), and that means that reading two files in parallel is actually fine, since otherwise Yona would need to block the execution there, so it can just block on both being read at once. Another important concept here is that the order of aliases defined in the let expression does matter . Yona doesn't just randomly re-arrange them based on dependencies alone. If it did, it could for example close those files before they are ever read. That would be incorrect. Yona just uses static analysis of this expression to determine which aliases can be \"batched\" and actually batches the execution if they provide underlying Promises. Then the whole expression is transformed into something like this: Execute batch 1 (sequentially, since File::open does not return a Promise): keys_file = File :: open \"tests/Keys.txt\" { : read } values_file = File :: open \"tests/Values.txt\" { : read } Execute batch 2 (in parallel, since File::read_lines does return a Promise): keys = File :: read_lines keys_file values = File :: read_lines values_file Result from batch 2 is a Promise aggregating both keys and values, which when complete, executes batch 3: () = File :: close keys_file () = File :: close values_file Finally, the whole let expression is now a Promise, so run the final expression whenever it is ready: Seq :: zip keys values |> Dict :: from_seq |> IO :: println Yona automatically chains runtime Promises as needed and, more than that, it \"unwraps\" them whenever they are complete, so the runtime doesn't actually get bloated with propagating Promises all over the place. As soon as a Promise is computed, it becomes just a regular value again. These concepts allows programmers to focus on expressing concurrent programs much more easily and not having to deal with the details of the actual execution order. Additionally, when code must be executed sequentially, without explicit dependencies, a special expression do is available.","title":"Example"},{"location":"about/#simplifying-the-example-by-using-resource-managemenet","text":"This example that concurrenly reads two files, line by line, and produces pairs of them as a dictionary can be implemented in Yona using its resource management features, as of Yona 0.8.1. Shorter version, equivalent in terms of features, but actually properly handling errors would look like: let keys = with File :: open \"tests/Keys.txt\" { : read } as keys_file File :: read_lines keys_file end values = with File :: open \"tests/Values.txt\" { : read } as values_file File :: read_lines values_file end in Seq :: zip keys values |> Dict :: from_seq Note that if error arises in the original example, files would not be closed. In this improved example they would. Otherwise, everything else regarding the non-blocking and parallel nature of this code stands.","title":"Simplifying the example by using resource managemenet"},{"location":"about/#implementation","text":"In terms of implementation, the runtime system of Yona can be viewed in terms of promise pipelineing or call-streams. The difference is that this pipelining and promise abstraction as such is completely transparent to the programmer and exists solely on the runtime level.","title":"Implementation"},{"location":"about/#evaluation","text":"Evaluation of an Yona program consists of evaluating a single expression. This is important, because everything, including module definitions are simple expressions in Yona. Module loader then takes advantage of this principle, knowing that an imported module will be a file defining a module expression. It can simply evaluate it and retrieve the module itself.","title":"Evaluation"},{"location":"syntax/","text":"Programs in Yona consist always of evaluation of a single expression. In fact, any Yona program consists of exactly one expression. The syntax is intentionally very minimalistic and inspired by languages such as SML or Haskell. There are only a handful of keywords, however it is not as flexible in naming as Haskell for example. Yona programs have the ambition to be easily readable. Custom operators with names consisting of symbols alone are not that useful when reading a program for the first time. This is why Yona does not support custom operators named by symbols only. Supported operators are listed here . Yona does not have indentation specific parsing rules, but it does require new line at certain locations, which are noted in each individual expression descriptions. Comments are denoted by the # character and everything that follows this character until the end of line ( \\n or \\r\\n ) is considered a comment and ignored. The source code of a Yona program must be a valid UTF-8 text file. Terminology \u00b6 These are some common terms and phrases used throughout these texts explained to a user unfamiliar with functional concepts: Function application : simply function call. Currying : a transformation of functions that translates a function from callable as f(a, b, c) into callable as f(a)(b)(c) . Currying doesn\u2019t call a function. It just transforms it. The example uses JavaScript syntax for clarity. Alias : what would be a variable in other languages, but cannot have its value modified during program execution. Once set, this alias , or a name , always contains the same original value. Pattern : an expected shape of a value. If the value \"matches\" this pattern, then this value can also be deconstructed onto it. For instance a pattern can be a first element of a list and the rest. The first element can be also assigned to an alias (or the rest), provided that the value matched this pattern. Patterns can be nested and serve as a building blocks for describing data structure for matching and extracting values. Patterns may be as simple as an alias - that is also a pattern in a way. An alias will be matched if an only it is a new name, that was not previously assigned, or if it was, then only if the value is the same as the one previously assigned to it. Guard : guards are additional conditions that may be applied to patterns, that otherwise couldn't be expressed using pattern syntax. Typical example might be a function call to determine a type of a value for example. String interpolation : process of substituting values of variables into placeholders in a string. For instance, if there a template for saying hello to a person like \"Hello {parson}, nice to meet you!\", where the placeholder should be replaced with an actual person's name. This process is called string interpolation. Functions : definition and application \u00b6 Functions in Yona are defined in a very short and concise form. They may take arguments, which the function can pattern match on, and one function can be defined using multiple arguments. Function names must start with a lowercase letter, followed by any letters, numbers or underscores. A simple function to calculate a factorial can be written for example this way: factorial 1 = 1 factorial n = n * factorial ( n - 1 ) Each function case must be on a new line. More complex conditions in patterns can be specified in this way: factorial 1 = 1 factorial n | n > 1 = n * factorial ( n - 1 ) Which means that there is an additional condition for the n value to be greater than 0. There may be multiple guards for each pattern and they must each be on a new line. A guard starts with the | character, followed an expression that must evaluate to a boolean and finally an = and the expression to evaluate if the pattern matches and the guard is true . Guards are used to express conditions that must be met in order for the pattern to match. A pattern may have none, one or multiple guards, and the first one matching will cause the pattern to match. Note that function arguments may actually be full patterns, not just argument names. Patterns are described in the section named Pattern Matching . Yona additionally supports non-linear patterns, meaning that if a pattern contains the same name multiple times, than this name is required to match the same value so that the pattern would match. This can be handy when checking for one value to be present in multiple places/arguments without having to explicitly write a guard that would ensure the equality. Anonymous functions : aka lambdas \u00b6 Since functions are first-class citizens in Yona, it is necessary to provide means of passing functions as arguments, and also to define them without giving them a name. The following syntax is used in this case: \\a rgument_one argument_two -> argument_one argument_two # lambda function for summing its arguments A lambda function with no arguments is simply: \\-> :something . Function application : calling functions \u00b6 Calling a function simply means writing the name of the function and then specifying its arguments. If fewer arguments are provided than the function expects, this is considered a curried call, and the result of such function is a partially applied function, that can be called with the remaining arguments at a later point. So for example calling a factorial would look simply like this: factorial 5 Since Yona is a strictly evaluated language, meaning that arguments are evaluated before calling the function (as opposed to a lazy language, where arguments are only evaluated when actually used by the called function), there is one situation to be careful about and that is passing lambda functions of zero arguments as arguments to functions. This would be evaluated before actually calling the function. If there are no side-effects happening in the lambda, it might be perfectly fine, however if the lambda must be passed as a lambda, it needs to be wrapped into another lambda at the call-site, such as for example: let lambda = \\- > IO::println :hello in do_something_with \\- > lambda # instead of do_something_with lambda Then the do_something_with function will obtain its argument as a function and not a result of IO::println :hello function (that would be :hello btw). Pipes and operator precedence \u00b6 Since Yona is an ML-style language and, unlike many C-like languages, it does not use parentheses to denote a function application, it can become unclear which expressions are arguments of which function. Take for the following example: Seq :: take 5 Seq :: random 10 Is this a function call to the Seq::take function (that is a function take in the module Seq as explained later) with 3 arguments (5, Seq::random and 10) or is it Seq::random 10 supposed to be computed first and then its result used as a second argument to Seq::take ? If the latter, then it can be written this way: Seq :: take 5 ( Seq :: random 10 ) Since any expression can be put into parentheses and be given precedence in evaluation. Another way to write this would be using pipes : Seq :: take 5 <| Seq :: random 10 or Seq :: random 10 |> Seq :: take 5 These are all equivalent expression and it is up to the programmer's preference to decide which one to use. One nice feature that pipes have is that they can be used on multiple lines, such as: Seq :: random 10 |> Seq :: take 5 |> IO :: println let expression : defining local aliases / pattern matching in the scope of evaluated expression \u00b6 The let expression allows defining aliases in the scope of the executed expressions. Alias represents a name for some value, like a variable, unlike a variable though, its value may not be changed over time. This expression allows evaluating patterns as well, so it is possible to deconstruct a value from a sequence, tuple, set, dictionary or a record directly, for example: let ( 1 , second ) = ( 1 , 2 ) pattern = expression1 in expression2 As shown in this example, the let expression consists of two parts. Each line consists of an alias or a pattern on the left side, and the expression to evaluate on the right side. The result of this expression is then matched to the pattern on the left side, or simply assigned to an alias, depending on what is on the left side. The result of this let expression is the result of the expression2 expression. If a pattern on the left is not matched on any of the lines, the whole let expression raises a :nomatch exception. One line can use names defined in previous lines. Every alias/pattern must be defined on a new line. Note that the order of execution of the alias/pattern lines is not strictly sequential. Considering the example in the documentation homepage , some aliases can be executed as a single batch, in parallel, provided that two conditions are met: * the do not depend on each other (do not use names provided by other aliases in the same batch) * they return a runtime Promise (IO operations, or results of the async function) When both conditions are met, Yona can safely execute them concurrently, avoiding unnecessary blocking and effectively speeding up the program execution. do expression : sequencing side effects \u00b6 The do expression is used to define a sequence of side effecting expressions. This expression is very similar to the let expression in the sense that it allows defining aliases and patterns, however, it doesn't have a separate expression that would be used as a result of this expression. Instead the result of the last line is used as the result. do start_time = Time :: now ( : ok , line ) = File :: read_line f end_time = Time :: now printf line printf ( end_time - start_time ) end Note that unlike the case with the let expression, the order of executed expressions is guaranteed to be exactly the same as the order in which they are written. This is the main use-case of the do expression: to allow strict ordering of execution. It does not matter whether an expression returns a run-time level Promise (such as one that can be created by a IO call or by using the async function), the order defined in this expression is always guaranteed to be maintained. case expression : pattern matching \u00b6 case expression is used for pattern matching on an expression. Each line of this expression contains a pattern followed by an arrow -> and an expression that is evaluated in case of a successful pattern match. Patterns are tried in the order in which they are specified. The default case can be denoted by an underscore _ pattern that always evaluates as true. case File :: read_line f of ( : ok , line ) -> line ( : ok , : eof ) -> : eof err @ ( : error , _ ) -> err tuple # guard expressions below | tuple_size tuple == 3 -> : ok | true -> : ok _ -> ( : error , : unknown ) end Same as with function definition patterns, patterns in the case expression can contain guard expressions, as is the case in the tuple pattern in the example above. Patterns with a guard expression will be matched only the guard evaluated to true . Note that each pattern may have multiple guard expression, in which case the first one evaluated to true will match. Guards are tried in the order they are specified in. if expression : conditions \u00b6 if is a conditional expression that takes form: if expression then expression else expression Both the then and the else parts must be defined. The expression after if must evaluate to a boolean value. Empty sequences, dictionaries or similar will not work! New lines are allowed, but not required. with expression : resource management \u00b6 with expression handles resource management within its scope. It initilizes the scope with a context manager that is available within the scope its body. The syntax looks like this ( as alias part is optional): with contextManager as alias bodyExpression end The contextManager expression must return a context manager . If no alias is used, then the context manager is not meant to be interacted with directly. An example for this would be an STM transaction, that just needs to be present but there is no need to directly refer to it. Alternatively, if the alias is specified, as usually case with files, then the file created in the contextManager part of this expression can be directly accessed in bodyExpression . Example that reads all lines using File::read_lines function: with File :: open \"File.txt\" { : read } as file File :: read_lines file end with daemon expression : dropping result of a context manager expression \u00b6 with daemon is a special form of the with expression which behaves exactly the same way in relation to the resource management, but the difference is that unlike the standard with expression, it does not return the result of its body as the result, it returns a () instead. This way, whatever the body is doing, the with daemon expression does not need to wait for its completion, but it returns immediately. This is particularly useful when accepting socket connections. As soon as the socket connection is accepted, this expression will return () and the execution of its body is moved to the background. This is how one can easily implement concurrent servers in Yona. Example using Socket::accept function: let addr = \"127.0.0.1\" port = 5555 accept = \\ channel -> with daemon socket \\ Server :: accept channel as connection socket \\ Connection :: read_line connection |> socket \\ Connection :: write connection end in with socket \\ Server :: channel addr port as channel infi ( \\-> accept channel ) end module expression \u00b6 module is an expression representing a set of records (optional) and functions. A module must export at least one function, others may be private - usable only from functions defined within the same module. Records are always visible only within the same module and may not be exported. A module may be defined as a file - in this case, the file must take the name of the module + .yona . Also, see section about module loader for details regarding loading modules. module package\\ DemoMmodule exports function1 , function2 as record DataStructure = ( field_one , field_two ) function1 = : something function2 = : something_else end Calling functions from a module is denoted by a double colon: package\\ DemoModule :: function1 Modules must have capitalized names, while packages are expected to start with a lowercase letter. Module may also be defined dynamically, for example assigned to a name in a let expression: let some_module = module TestModule exports test_function as test_function = 5 end in some_module :: test_function In this case the name of the module does not matter, as the module is assigned to the test_module value. with expression : resource management \u00b6 with expression handles resource management within its scope. It initializes the scope with a context manager that is available within the scope its body. The syntax lookes like this ( as alias part is optional): with contextManager as alias bodyExpression end The contextManager expression must return a context manager . If no alias is used, then the context manager is not meant to be interacted with directly. An example for this would be an STM transaction, that just needs to be present but there is no need to directly refer to it. Alternatively, if the alias is specified, as usually case with files, then the file creted in the contextManager part of this expression can be directly accessed in bodyExpression . Example that reads all lines using File::read_lines function: with File :: open \"File.txt\" { : read } as file File :: read_lines file end Packages \u00b6 Packages are logical units for organizing modules. Modules stored in packages must follow a folder structure which is exactly the same as the package path. Records \u00b6 New data structures in Yona can be implemented simply by using tuples. However, as tuples grow in number of elements, it may become useful to name those elements rather than always matching on a particular n-th element. To do so, Yona provides records . Records are essentially named tuples with names for each element and can be used to refer to a particular element by that name. Records exist within the scope of a module and cannot be imported by or exported to other modules. Modules are meant to provide an interface via functions alone. A record is defined by its name and a list of field names. Here's an example of a record definition: record Car = ( brand , model , engine_type ) To initialize a new record instance, following syntax should be used: let car = Car ( brand = \"Audi\" , model = \"A4\" , engine_type = \"TDI\" ) in ... Note that not all fields are required when initializing record. Uninitialized fields are then initialized with value of () (unit). At least one field must be provided during initialization, though (its value may be unit as well). Updating an existing record instance (actually creating a new one with some fields changed) can be done using this syntax: let new_car = car ( model = \"A6\" ) # this is same as Car(brand=\"Audi\", model=\"A4\", engine_type=\"TDI\") in ... To access a field from a record instance a dot syntax is used: IO::println new_car.model # will print A6 Pattern matching on records is very easy as well: order_car Car ( brand = \"Audi\" , model = model ) = order_audi_model model order_car Car ( brand = \"Lexus\" , model = model ) = order_lexus_model model order_car any_car@Car = order_elsewhere any_car # the whole record_instance is available under name any_car import expression : importing functions from other modules \u00b6 Normally, it is not necessary to import modules, as it is often the case in many other languages. Functions from another modules can be called without explicitly declaring them as imported. However, Yona has a special import expression (and as such it returns the value of the expression followed by the in keyword) that allows importing functions from modules and in that way create aliases for otherwise fully qualified names. import funone as one_fun, otherfun from package \\S impleModule funtwo from other \\p ackage \\N otSimpleModule in onefun :something # expression that is the return value of the whole import expression Note that importing functions from multiple modules is possible, they just have to be put on new lines. Functions can be renamed using the as keyword. See the section about module loader for more details regarding loading modules. raise , try / catch expressions : raising and catching exceptions \u00b6 Yona is not a pure language, therefore it allows raising exceptions. Exceptions in Yona are represented as a tuple of a symbol and a message. Message can be empty, if not provided as an argument to the keyword/function raise . Exceptions in Yona consist of three components. First component, is the type of the exception, represented as a symbol. The second component is a string description of the exception - an error message. Last component is the stacktrace which is appended by the runtime automatically. Raising an exception can be accomplished by the raise expression: raise :badarg \"Error message\" # where :badarg is a symbol denoting type of exception Catching an exception is done with try / catch . Catching an exception is essentially pattern matching on an exception triple that consists of all three exception components. try expression catch (:badarg, error_msg, stacktrace) -> :error (:io_error, error_msg, stacktrace) -> :error end Loops : recursion and generators \u00b6 Yona is a functional language with immutable data types and no variables. This means that imperative constructs for loops, such as while or for cannot be used. Instead, iteration is normally achieved via recursion. Yona is able to optimize tail-recursive function calls, so they would not stack overflow. A typical Python solution using mutation might look like this: def factorial ( n ): i = n while i > 1 : i -= 1 n *= i return n However, this solution requires mutable variables, which are not present in Yona. So, an example of a recursive function to calculate factorial in Yona would be: factorial 1 = 1 factorial n = n * factorial ( n - 1 ) Note that this function is actually not tail-recursive. This is because factorial (n - 1) is evaluated before n * (factorial (n - 1)) , so the multiplication is the last expression here and thus there is a potential for stack overflow. That might often not be an issue, just something to consider when writing recursive functions. It would actually not be very difficult to rewrite this function to be tail-recursive, such as: factTR 0 a = a factTR n a = factTR ( n - 1 ) ( n * a ) factorial n = factTR n 1 In this case there is a helper function that is tail-recursive, since the last expression in that function is the call to itself. Generators \u00b6 Another way to iterate over a collection (sequence, set or dictionary) are generator expressions. They allow transforming an existing collection into another one (of possibly different type, such as sequence to dictionary). Generators consist of three or four components: Syntax for a generator generating a sequence from a set: [ x * 2 | x <- { 1 , 2 , 3 }] # the source collection is a set of 1 , 2 , 3 , so the result is [ 2 , 4 , 6 ] [ x * 2 | x <- { 1 , 2 , 3 } if x % 2 == 0 ] # generator with a condition , so the result is [ 4 ] Syntax for a generator generating a set from a sequence: [ x * 2 | x <- [ 1 , 2 , 3 ]] # the source collection is a set of 1 , 2 , 3 , so the result is { 2 , 4 , 6 } [ x * 2 | x <- [ 1 , 2 , 3 ] if x % 2 == 0 ] # generator with a condition , so the result is { 4 } Syntax for a generator generating a dictionary: { key = val * 2 | key = val <- { : a = 1 , : b = 2 , : c = 3 }} # the source collection is a set of 1 , 2 , 3 , so the result is { : a = 2 , : b = 4 , : c = 6 } { key = val * 2 | key = val <- { : a = 1 , : b = 2 , : c = 3 } if val % 2 == 0 } # generator with a condition , so the result is { : b = 4 } Generators are an easy an convenient way to transform built-in collections. They are, however, themselves implemented using the reusable Transducers module. For example, a set generator without using the above mentioned syntax \"sugar\" could look like: Transducers :: filter \\ val -> val < 0 ( \\-> 0 , \\ acc val -> acc + val , \\ acc -> acc * 2 ) |> Set :: reduce [ 1 , 2 , 3 ] The description of the Transducer functions can be found in the module itself. Transducers may be combined in order to create more complex transformations. Also, custom collection may implement their version of a reduce function that accepts a transducer and reduces the collection as desired. Strings \u00b6 Strings in Yona are technically sequences of UTF-8 characters. Character in Yona can be written between apostrophes. Working with strings is then no different than working with any other sequence. String literals can be multi-line as well. There is no special syntax for multi-line strings and a single pair of quotes is used to denote all string literals. String Interpolation \u00b6 Yona supports string interpolation for convenience in formatting strings. The syntax is as follows: \"this string contains an interpolated {variable}\" In this string the {variable} part is replaced with whatever contents of the variable . Technically, variable is a name of a bound variable, or an expression in parentheses. It is also possible to use string interpolation with alignment option, which can be used for formatting tabular outputs: \"{column1,10}|{column2, 10}\" The alignment number will make the value align to the right and filled with spaces to the left, if positive. If the number is negative, the opposite applies and the text is aligned to the left with spaces on the right. The number can be either a literal value or any expression that returns an integer.","title":"Syntax"},{"location":"syntax/#terminology","text":"These are some common terms and phrases used throughout these texts explained to a user unfamiliar with functional concepts: Function application : simply function call. Currying : a transformation of functions that translates a function from callable as f(a, b, c) into callable as f(a)(b)(c) . Currying doesn\u2019t call a function. It just transforms it. The example uses JavaScript syntax for clarity. Alias : what would be a variable in other languages, but cannot have its value modified during program execution. Once set, this alias , or a name , always contains the same original value. Pattern : an expected shape of a value. If the value \"matches\" this pattern, then this value can also be deconstructed onto it. For instance a pattern can be a first element of a list and the rest. The first element can be also assigned to an alias (or the rest), provided that the value matched this pattern. Patterns can be nested and serve as a building blocks for describing data structure for matching and extracting values. Patterns may be as simple as an alias - that is also a pattern in a way. An alias will be matched if an only it is a new name, that was not previously assigned, or if it was, then only if the value is the same as the one previously assigned to it. Guard : guards are additional conditions that may be applied to patterns, that otherwise couldn't be expressed using pattern syntax. Typical example might be a function call to determine a type of a value for example. String interpolation : process of substituting values of variables into placeholders in a string. For instance, if there a template for saying hello to a person like \"Hello {parson}, nice to meet you!\", where the placeholder should be replaced with an actual person's name. This process is called string interpolation.","title":"Terminology"},{"location":"syntax/#functions-definition-and-application","text":"Functions in Yona are defined in a very short and concise form. They may take arguments, which the function can pattern match on, and one function can be defined using multiple arguments. Function names must start with a lowercase letter, followed by any letters, numbers or underscores. A simple function to calculate a factorial can be written for example this way: factorial 1 = 1 factorial n = n * factorial ( n - 1 ) Each function case must be on a new line. More complex conditions in patterns can be specified in this way: factorial 1 = 1 factorial n | n > 1 = n * factorial ( n - 1 ) Which means that there is an additional condition for the n value to be greater than 0. There may be multiple guards for each pattern and they must each be on a new line. A guard starts with the | character, followed an expression that must evaluate to a boolean and finally an = and the expression to evaluate if the pattern matches and the guard is true . Guards are used to express conditions that must be met in order for the pattern to match. A pattern may have none, one or multiple guards, and the first one matching will cause the pattern to match. Note that function arguments may actually be full patterns, not just argument names. Patterns are described in the section named Pattern Matching . Yona additionally supports non-linear patterns, meaning that if a pattern contains the same name multiple times, than this name is required to match the same value so that the pattern would match. This can be handy when checking for one value to be present in multiple places/arguments without having to explicitly write a guard that would ensure the equality.","title":"Functions: definition and application"},{"location":"syntax/#anonymous-functions-aka-lambdas","text":"Since functions are first-class citizens in Yona, it is necessary to provide means of passing functions as arguments, and also to define them without giving them a name. The following syntax is used in this case: \\a rgument_one argument_two -> argument_one argument_two # lambda function for summing its arguments A lambda function with no arguments is simply: \\-> :something .","title":"Anonymous functions: aka lambdas"},{"location":"syntax/#function-application-calling-functions","text":"Calling a function simply means writing the name of the function and then specifying its arguments. If fewer arguments are provided than the function expects, this is considered a curried call, and the result of such function is a partially applied function, that can be called with the remaining arguments at a later point. So for example calling a factorial would look simply like this: factorial 5 Since Yona is a strictly evaluated language, meaning that arguments are evaluated before calling the function (as opposed to a lazy language, where arguments are only evaluated when actually used by the called function), there is one situation to be careful about and that is passing lambda functions of zero arguments as arguments to functions. This would be evaluated before actually calling the function. If there are no side-effects happening in the lambda, it might be perfectly fine, however if the lambda must be passed as a lambda, it needs to be wrapped into another lambda at the call-site, such as for example: let lambda = \\- > IO::println :hello in do_something_with \\- > lambda # instead of do_something_with lambda Then the do_something_with function will obtain its argument as a function and not a result of IO::println :hello function (that would be :hello btw).","title":"Function application: calling functions"},{"location":"syntax/#pipes-and-operator-precedence","text":"Since Yona is an ML-style language and, unlike many C-like languages, it does not use parentheses to denote a function application, it can become unclear which expressions are arguments of which function. Take for the following example: Seq :: take 5 Seq :: random 10 Is this a function call to the Seq::take function (that is a function take in the module Seq as explained later) with 3 arguments (5, Seq::random and 10) or is it Seq::random 10 supposed to be computed first and then its result used as a second argument to Seq::take ? If the latter, then it can be written this way: Seq :: take 5 ( Seq :: random 10 ) Since any expression can be put into parentheses and be given precedence in evaluation. Another way to write this would be using pipes : Seq :: take 5 <| Seq :: random 10 or Seq :: random 10 |> Seq :: take 5 These are all equivalent expression and it is up to the programmer's preference to decide which one to use. One nice feature that pipes have is that they can be used on multiple lines, such as: Seq :: random 10 |> Seq :: take 5 |> IO :: println","title":"Pipes and operator precedence"},{"location":"syntax/#let-expression","text":"The let expression allows defining aliases in the scope of the executed expressions. Alias represents a name for some value, like a variable, unlike a variable though, its value may not be changed over time. This expression allows evaluating patterns as well, so it is possible to deconstruct a value from a sequence, tuple, set, dictionary or a record directly, for example: let ( 1 , second ) = ( 1 , 2 ) pattern = expression1 in expression2 As shown in this example, the let expression consists of two parts. Each line consists of an alias or a pattern on the left side, and the expression to evaluate on the right side. The result of this expression is then matched to the pattern on the left side, or simply assigned to an alias, depending on what is on the left side. The result of this let expression is the result of the expression2 expression. If a pattern on the left is not matched on any of the lines, the whole let expression raises a :nomatch exception. One line can use names defined in previous lines. Every alias/pattern must be defined on a new line. Note that the order of execution of the alias/pattern lines is not strictly sequential. Considering the example in the documentation homepage , some aliases can be executed as a single batch, in parallel, provided that two conditions are met: * the do not depend on each other (do not use names provided by other aliases in the same batch) * they return a runtime Promise (IO operations, or results of the async function) When both conditions are met, Yona can safely execute them concurrently, avoiding unnecessary blocking and effectively speeding up the program execution.","title":"let expression: defining local aliases / pattern matching in the scope of evaluated expression"},{"location":"syntax/#do-expression","text":"The do expression is used to define a sequence of side effecting expressions. This expression is very similar to the let expression in the sense that it allows defining aliases and patterns, however, it doesn't have a separate expression that would be used as a result of this expression. Instead the result of the last line is used as the result. do start_time = Time :: now ( : ok , line ) = File :: read_line f end_time = Time :: now printf line printf ( end_time - start_time ) end Note that unlike the case with the let expression, the order of executed expressions is guaranteed to be exactly the same as the order in which they are written. This is the main use-case of the do expression: to allow strict ordering of execution. It does not matter whether an expression returns a run-time level Promise (such as one that can be created by a IO call or by using the async function), the order defined in this expression is always guaranteed to be maintained.","title":"do expression: sequencing side effects"},{"location":"syntax/#case-expression-pattern-matching","text":"case expression is used for pattern matching on an expression. Each line of this expression contains a pattern followed by an arrow -> and an expression that is evaluated in case of a successful pattern match. Patterns are tried in the order in which they are specified. The default case can be denoted by an underscore _ pattern that always evaluates as true. case File :: read_line f of ( : ok , line ) -> line ( : ok , : eof ) -> : eof err @ ( : error , _ ) -> err tuple # guard expressions below | tuple_size tuple == 3 -> : ok | true -> : ok _ -> ( : error , : unknown ) end Same as with function definition patterns, patterns in the case expression can contain guard expressions, as is the case in the tuple pattern in the example above. Patterns with a guard expression will be matched only the guard evaluated to true . Note that each pattern may have multiple guard expression, in which case the first one evaluated to true will match. Guards are tried in the order they are specified in.","title":"case expression: pattern matching"},{"location":"syntax/#if-expression-conditions","text":"if is a conditional expression that takes form: if expression then expression else expression Both the then and the else parts must be defined. The expression after if must evaluate to a boolean value. Empty sequences, dictionaries or similar will not work! New lines are allowed, but not required.","title":"if expression: conditions"},{"location":"syntax/#with-expression","text":"with expression handles resource management within its scope. It initilizes the scope with a context manager that is available within the scope its body. The syntax looks like this ( as alias part is optional): with contextManager as alias bodyExpression end The contextManager expression must return a context manager . If no alias is used, then the context manager is not meant to be interacted with directly. An example for this would be an STM transaction, that just needs to be present but there is no need to directly refer to it. Alternatively, if the alias is specified, as usually case with files, then the file created in the contextManager part of this expression can be directly accessed in bodyExpression . Example that reads all lines using File::read_lines function: with File :: open \"File.txt\" { : read } as file File :: read_lines file end","title":"with expression: resource management"},{"location":"syntax/#with-daemon-expression-dropping-result-of-a-context-manager-expression","text":"with daemon is a special form of the with expression which behaves exactly the same way in relation to the resource management, but the difference is that unlike the standard with expression, it does not return the result of its body as the result, it returns a () instead. This way, whatever the body is doing, the with daemon expression does not need to wait for its completion, but it returns immediately. This is particularly useful when accepting socket connections. As soon as the socket connection is accepted, this expression will return () and the execution of its body is moved to the background. This is how one can easily implement concurrent servers in Yona. Example using Socket::accept function: let addr = \"127.0.0.1\" port = 5555 accept = \\ channel -> with daemon socket \\ Server :: accept channel as connection socket \\ Connection :: read_line connection |> socket \\ Connection :: write connection end in with socket \\ Server :: channel addr port as channel infi ( \\-> accept channel ) end","title":"with daemon expression: dropping result of a context manager expression"},{"location":"syntax/#module-expression","text":"module is an expression representing a set of records (optional) and functions. A module must export at least one function, others may be private - usable only from functions defined within the same module. Records are always visible only within the same module and may not be exported. A module may be defined as a file - in this case, the file must take the name of the module + .yona . Also, see section about module loader for details regarding loading modules. module package\\ DemoMmodule exports function1 , function2 as record DataStructure = ( field_one , field_two ) function1 = : something function2 = : something_else end Calling functions from a module is denoted by a double colon: package\\ DemoModule :: function1 Modules must have capitalized names, while packages are expected to start with a lowercase letter. Module may also be defined dynamically, for example assigned to a name in a let expression: let some_module = module TestModule exports test_function as test_function = 5 end in some_module :: test_function In this case the name of the module does not matter, as the module is assigned to the test_module value.","title":"module expression"},{"location":"syntax/#with-expression","text":"with expression handles resource management within its scope. It initializes the scope with a context manager that is available within the scope its body. The syntax lookes like this ( as alias part is optional): with contextManager as alias bodyExpression end The contextManager expression must return a context manager . If no alias is used, then the context manager is not meant to be interacted with directly. An example for this would be an STM transaction, that just needs to be present but there is no need to directly refer to it. Alternatively, if the alias is specified, as usually case with files, then the file creted in the contextManager part of this expression can be directly accessed in bodyExpression . Example that reads all lines using File::read_lines function: with File :: open \"File.txt\" { : read } as file File :: read_lines file end","title":"with expression: resource management"},{"location":"syntax/#packages","text":"Packages are logical units for organizing modules. Modules stored in packages must follow a folder structure which is exactly the same as the package path.","title":"Packages"},{"location":"syntax/#records","text":"New data structures in Yona can be implemented simply by using tuples. However, as tuples grow in number of elements, it may become useful to name those elements rather than always matching on a particular n-th element. To do so, Yona provides records . Records are essentially named tuples with names for each element and can be used to refer to a particular element by that name. Records exist within the scope of a module and cannot be imported by or exported to other modules. Modules are meant to provide an interface via functions alone. A record is defined by its name and a list of field names. Here's an example of a record definition: record Car = ( brand , model , engine_type ) To initialize a new record instance, following syntax should be used: let car = Car ( brand = \"Audi\" , model = \"A4\" , engine_type = \"TDI\" ) in ... Note that not all fields are required when initializing record. Uninitialized fields are then initialized with value of () (unit). At least one field must be provided during initialization, though (its value may be unit as well). Updating an existing record instance (actually creating a new one with some fields changed) can be done using this syntax: let new_car = car ( model = \"A6\" ) # this is same as Car(brand=\"Audi\", model=\"A4\", engine_type=\"TDI\") in ... To access a field from a record instance a dot syntax is used: IO::println new_car.model # will print A6 Pattern matching on records is very easy as well: order_car Car ( brand = \"Audi\" , model = model ) = order_audi_model model order_car Car ( brand = \"Lexus\" , model = model ) = order_lexus_model model order_car any_car@Car = order_elsewhere any_car # the whole record_instance is available under name any_car","title":"Records"},{"location":"syntax/#import-expression-importing-functions-from-other-modules","text":"Normally, it is not necessary to import modules, as it is often the case in many other languages. Functions from another modules can be called without explicitly declaring them as imported. However, Yona has a special import expression (and as such it returns the value of the expression followed by the in keyword) that allows importing functions from modules and in that way create aliases for otherwise fully qualified names. import funone as one_fun, otherfun from package \\S impleModule funtwo from other \\p ackage \\N otSimpleModule in onefun :something # expression that is the return value of the whole import expression Note that importing functions from multiple modules is possible, they just have to be put on new lines. Functions can be renamed using the as keyword. See the section about module loader for more details regarding loading modules.","title":"import expression: importing functions from other modules"},{"location":"syntax/#exceptions","text":"Yona is not a pure language, therefore it allows raising exceptions. Exceptions in Yona are represented as a tuple of a symbol and a message. Message can be empty, if not provided as an argument to the keyword/function raise . Exceptions in Yona consist of three components. First component, is the type of the exception, represented as a symbol. The second component is a string description of the exception - an error message. Last component is the stacktrace which is appended by the runtime automatically. Raising an exception can be accomplished by the raise expression: raise :badarg \"Error message\" # where :badarg is a symbol denoting type of exception Catching an exception is done with try / catch . Catching an exception is essentially pattern matching on an exception triple that consists of all three exception components. try expression catch (:badarg, error_msg, stacktrace) -> :error (:io_error, error_msg, stacktrace) -> :error end","title":"raise, try/catch expressions: raising and catching exceptions"},{"location":"syntax/#loops-recursion-and-generators","text":"Yona is a functional language with immutable data types and no variables. This means that imperative constructs for loops, such as while or for cannot be used. Instead, iteration is normally achieved via recursion. Yona is able to optimize tail-recursive function calls, so they would not stack overflow. A typical Python solution using mutation might look like this: def factorial ( n ): i = n while i > 1 : i -= 1 n *= i return n However, this solution requires mutable variables, which are not present in Yona. So, an example of a recursive function to calculate factorial in Yona would be: factorial 1 = 1 factorial n = n * factorial ( n - 1 ) Note that this function is actually not tail-recursive. This is because factorial (n - 1) is evaluated before n * (factorial (n - 1)) , so the multiplication is the last expression here and thus there is a potential for stack overflow. That might often not be an issue, just something to consider when writing recursive functions. It would actually not be very difficult to rewrite this function to be tail-recursive, such as: factTR 0 a = a factTR n a = factTR ( n - 1 ) ( n * a ) factorial n = factTR n 1 In this case there is a helper function that is tail-recursive, since the last expression in that function is the call to itself.","title":"Loops: recursion and generators"},{"location":"syntax/#generators","text":"Another way to iterate over a collection (sequence, set or dictionary) are generator expressions. They allow transforming an existing collection into another one (of possibly different type, such as sequence to dictionary). Generators consist of three or four components: Syntax for a generator generating a sequence from a set: [ x * 2 | x <- { 1 , 2 , 3 }] # the source collection is a set of 1 , 2 , 3 , so the result is [ 2 , 4 , 6 ] [ x * 2 | x <- { 1 , 2 , 3 } if x % 2 == 0 ] # generator with a condition , so the result is [ 4 ] Syntax for a generator generating a set from a sequence: [ x * 2 | x <- [ 1 , 2 , 3 ]] # the source collection is a set of 1 , 2 , 3 , so the result is { 2 , 4 , 6 } [ x * 2 | x <- [ 1 , 2 , 3 ] if x % 2 == 0 ] # generator with a condition , so the result is { 4 } Syntax for a generator generating a dictionary: { key = val * 2 | key = val <- { : a = 1 , : b = 2 , : c = 3 }} # the source collection is a set of 1 , 2 , 3 , so the result is { : a = 2 , : b = 4 , : c = 6 } { key = val * 2 | key = val <- { : a = 1 , : b = 2 , : c = 3 } if val % 2 == 0 } # generator with a condition , so the result is { : b = 4 } Generators are an easy an convenient way to transform built-in collections. They are, however, themselves implemented using the reusable Transducers module. For example, a set generator without using the above mentioned syntax \"sugar\" could look like: Transducers :: filter \\ val -> val < 0 ( \\-> 0 , \\ acc val -> acc + val , \\ acc -> acc * 2 ) |> Set :: reduce [ 1 , 2 , 3 ] The description of the Transducer functions can be found in the module itself. Transducers may be combined in order to create more complex transformations. Also, custom collection may implement their version of a reduce function that accepts a transducer and reduces the collection as desired.","title":"Generators"},{"location":"syntax/#strings","text":"Strings in Yona are technically sequences of UTF-8 characters. Character in Yona can be written between apostrophes. Working with strings is then no different than working with any other sequence. String literals can be multi-line as well. There is no special syntax for multi-line strings and a single pair of quotes is used to denote all string literals.","title":"Strings"},{"location":"syntax/#string-interpolation","text":"Yona supports string interpolation for convenience in formatting strings. The syntax is as follows: \"this string contains an interpolated {variable}\" In this string the {variable} part is replaced with whatever contents of the variable . Technically, variable is a name of a bound variable, or an expression in parentheses. It is also possible to use string interpolation with alignment option, which can be used for formatting tabular outputs: \"{column1,10}|{column2, 10}\" The alignment number will make the value align to the right and filled with spaces to the left, if positive. If the number is negative, the opposite applies and the text is aligned to the left with spaces on the right. The number can be either a literal value or any expression that returns an integer.","title":"String Interpolation"},{"location":"features/data-types/","text":"Yona is dynamically typed language, meaning that types are checked during runtime. Values in Yona are represented using following data types: boolean - true or false integer - 64 bit number double - double-precision 64-bit IEEE 754 floating point, written either using a floating point number or by an integer with an f suffix byte - single byte, written as an integer literal with a b suffix identifier: small letter followed by any number of letters or numbers or underscores character - a single UTF-8 character in single quotes: 'c' string - UTF-8 characters in quotes: \"hello world\" . String is technically a sequence of characters (highly optimized internally, but for a programmer it looks and feels as a sequence). symbols - preceded by a colon: :error tuple - in parenthesis: (1, 2, 3) sequence - biderctional list like structure with constant time random access in brackets: [1, 2, 3] dictionary - in curly braces: {:one = 1, :two = 2} set - in curly braces: {1, 2, 3} anonymous function(lambda): \\first_arg second_arg -> first_arg + second_arg unit, or () - representing no value native object: underlying Java object that is used by some stdlib functions, such as File descriptor stm - software transactional memory var - reference to entry in the software transactional memory","title":"Data Types"},{"location":"features/module-loader/","text":"Yona's module loader is very simple and respects environmental variable YONA_PATH . If this variable is not set, then current working directory is used as a base directory for loading modules. Multiple paths may be separated with a default platform path separator: : on UNIX and ; on Windows. Modules are loaded in the order of directories specified in the YONA_PATH , and first found location wins. Modules are cached in Yona, and if a module was already loaded once, then changes made to it on a disk will not be reflected. Tip It is possible to execute a module (run yona -f file.yona ) if this file is a module exporting a zero-argument function main .","title":"Module Loader"},{"location":"features/operators/","text":"Binary Operators \u00b6 These are all the operations supposorted by Yona's binary operators. Combinations of other data types than listed here will result in a TypeError . Operator Left operand Right operand Description & integer integer bitwise and & set set set intersection & dict dict dict intersection | integer integer bitwise or | set set set union | dict dict dict union ^ integer integer bitwise xor ^ set set set symetric difference ^ dict dict dict symetric difference -- set any remove element from a set -- dict any remove key from a dict / integer integer division / double double division == integer integer equality == double double equality == byte byte equality == function function referential equality == () () equality - alwyays true == tuple tuple equality == module module equality == sequence sequence equality == dict dict equality == set set equality == native native equality > integer integer greater than > double double greater than > byte byte greater than > function function always false > () () greater than - alwyays false > dict dict left is a strict superset of the right > set set left is a strict superset of the right >= integer integer greater than or equals >= double double greater than or equals >= byte byte greater than or equals >= function function referential equality >= () () always true >= dict dict left is a superset of the right >= set set left is a superset of the right != integer integer non-equality != double double non-equality != byte byte non-equality != function function referential non-equality != () () non-equality - alwyays false != tuple tuple non-equality != module module non-equality != sequence sequence non-equality != dict dict non-equality != set set non-equality != native native non-equality < integer integer lower than < double double lower than < byte byte lower than < function function always false < () () lower than - alwyays false < dict dict left is a strict subset of the right < set set left is a strict subset of the right <= integer integer lower than or equals <= double double lower than or equals <= byte byte lower than or equals <= function function referential equality <= () () always true <= dict dict left is a subset of the right <= set set left is a subset of the right in any set left is a member of the right in any dict left is a member of the right in any seq left is a member of the right ++ seq seq concatenation << integer integer signed left shift >> integer integer signed right shift >>> integer integer zero fill right shift && boolean boolean logical and || boolean boolean logical or - integer integer arithmetic subtraction - float float arithmetic subtraction - dict any TBD: review % integer integer arithmetic modulo % float float arithmetic modulo * integer integer arithmetic multiplication * float float arithmetic multiplication ** float float first argument raised to the power of the second argument - integer integer arithmetic subtraction - float float arithmetic subtraction - set any remove element from the left - dict tuple remove element from the left + integer integer arithmetic addition + float float arithmetic addition + set any add element to the left + dict tuple add tuple (key, value) to the left -| any seq add element to the beginning of a sequence |- seq any add element to the end of a sequence Unary operators \u00b6 In addition to the binary operators in the table above, Yona supports negation operator ~ which can be applied either to integer or boolean values and will result in bitwise complement, or boolean negation respectively.","title":"Operators"},{"location":"features/operators/#binary-operators","text":"These are all the operations supposorted by Yona's binary operators. Combinations of other data types than listed here will result in a TypeError . Operator Left operand Right operand Description & integer integer bitwise and & set set set intersection & dict dict dict intersection | integer integer bitwise or | set set set union | dict dict dict union ^ integer integer bitwise xor ^ set set set symetric difference ^ dict dict dict symetric difference -- set any remove element from a set -- dict any remove key from a dict / integer integer division / double double division == integer integer equality == double double equality == byte byte equality == function function referential equality == () () equality - alwyays true == tuple tuple equality == module module equality == sequence sequence equality == dict dict equality == set set equality == native native equality > integer integer greater than > double double greater than > byte byte greater than > function function always false > () () greater than - alwyays false > dict dict left is a strict superset of the right > set set left is a strict superset of the right >= integer integer greater than or equals >= double double greater than or equals >= byte byte greater than or equals >= function function referential equality >= () () always true >= dict dict left is a superset of the right >= set set left is a superset of the right != integer integer non-equality != double double non-equality != byte byte non-equality != function function referential non-equality != () () non-equality - alwyays false != tuple tuple non-equality != module module non-equality != sequence sequence non-equality != dict dict non-equality != set set non-equality != native native non-equality < integer integer lower than < double double lower than < byte byte lower than < function function always false < () () lower than - alwyays false < dict dict left is a strict subset of the right < set set left is a strict subset of the right <= integer integer lower than or equals <= double double lower than or equals <= byte byte lower than or equals <= function function referential equality <= () () always true <= dict dict left is a subset of the right <= set set left is a subset of the right in any set left is a member of the right in any dict left is a member of the right in any seq left is a member of the right ++ seq seq concatenation << integer integer signed left shift >> integer integer signed right shift >>> integer integer zero fill right shift && boolean boolean logical and || boolean boolean logical or - integer integer arithmetic subtraction - float float arithmetic subtraction - dict any TBD: review % integer integer arithmetic modulo % float float arithmetic modulo * integer integer arithmetic multiplication * float float arithmetic multiplication ** float float first argument raised to the power of the second argument - integer integer arithmetic subtraction - float float arithmetic subtraction - set any remove element from the left - dict tuple remove element from the left + integer integer arithmetic addition + float float arithmetic addition + set any add element to the left + dict tuple add tuple (key, value) to the left -| any seq add element to the beginning of a sequence |- seq any add element to the end of a sequence","title":"Binary Operators"},{"location":"features/operators/#unary-operators","text":"In addition to the binary operators in the table above, Yona supports negation operator ~ which can be applied either to integer or boolean values and will result in bitwise complement, or boolean negation respectively.","title":"Unary operators"},{"location":"features/pattern-matching/","text":"Pattern matching is the most important feature for control flow in Yona. It allows simple, short way of specifying patterns for the built in types, specifically: Pattern matching, in combination with recursion are the basis of the control flow in Yona. Scalar values - integer, float, byte, character, boolean, symbol \u00b6 Pattern matching for scalar values is super simple. The pattern looks is the value itself, for example: case expr of 5 -> do_something 6 -> do_something_else end Tuples \u00b6 Pattern matching on tuples: case expr of ( : ok , value ) -> do_something value # value contains the second element of the tuple ( : error , message ) -> IO :: println message end Records \u00b6 Pattern matching on records is described in the section about Records. Underscore pattern \u00b6 The underscore pattern _ will match any value. Sequence & reverse sequence, multiple head & tails & their combinations in patterns \u00b6 Sequence is a biderctional structure and can be easily pattern matched from either left or right side. Yona allows pattern matching on more than a single element as well: Matching sequence on the beginning \u00b6 case [ 1 ] of 1 -| [] -> 2 [] -> 3 _ -> 9 end This code will result in 2 . Yona allows matching on more than just one element in the beginning: case [ 1 , 2 , 3 , 4 ] of 1 -| 2 -| [] -> 2 1 -| 2 -| tail -> tail [] -> 3 _ -> 9 end Will produce [3, 4] . Matching sequence on the end \u00b6 case [ 1 ] of [] |- 1 -> 2 [] -> 3 _ -> 9 end This code will result in 2 . Obtaining a remainer of a sequnce \u00b6 case [ 1 , 2 , 3 ] of 1 -| [] -> 2 1 -| tail -> tail [] -> 3 _ -> 9 end This code will result in [2, 3] . This could also be done from the other end of the sequence, using |- operator instead (and reversing head/tails sections). Matching a sequence elements \u00b6 case arg of [] -> 3 [ 1 , second , 3 ] -> second _ -> 9 end Will produce 2 . Matching strings \u00b6 Since strings are sequences of characters, they can be pattern matched on as such. Alternatively string literals may be used as well, or any combination of the two. For example: case \"hello there\" of 'h' -| 'e' -| _ |- 'r' |- 'e' -> 0 _ -> 1 end Which will produce a 0 . Another example: case [ 'a' , 'b' , 'c' ] of h -| \"bc\" -> h _ -> 1 end Which produces an 'a' . Dictionary patterns \u00b6 Dictionaries can be matched on both keys and values. Example: case { \"a\" = 1 , \"b\" = 2 } of { \"b\" = 3 } -> 3 { \"a\" = 1 , \"b\" = bb } -> bb _ -> 9 end This will result in 2 . \"As\" patterns \u00b6 Sometimes it can be useful to name a collection (sequence, set or dictionary) or a record in a pattern for later use. For example when matching on a record type, but ignoring all the fields. This can be done using @ syntax in Yona: let mod = module TestMod exports testfun as record TestRecord = ( argone , argtwo ) testfun = case TestRecord ( argone = 1 , argtwo = 2 ) of 2 -> 0 x @ TestRecord -> x . argone _ -> 2 end end in mod :: testfun This slightly with an inlined module definition more complex example will produce 1 . Remember that records exist on a module level only. let expression patterns \u00b6 let expression allows using patterns on the left side of its assignments. In that way it is not necessary to use case expression explicitly. * do expression patterns \u00b6 do expression similarly to let expressions allows defining aliases, and they can be patterns on the left side. Unlike let expression, do expression does not require value assignment, but still allows it. For example: do ( one , _ ) = ( 1 , :unused ) IO :: println one two = 2 one + two end Which will result in 3 after 1 is printed. case patterns \u00b6 This is THE pattern matching expression. It maches a value against a list of patterns and executes the expression of the matching pattern. Function & lambda patterns \u00b6 Functions and lambdas may be defined using patterns as explained in the section about functions. The only limitation of the lambda definitions, is that they may only contain one pattern. This is not used much for control flow, but still useful for deconstructing some data structures. If lambda needs to pattern match multiple patterns, either define it as a named function, or use case expression. Guard expressions \u00b6 Patterns may be enhanced further with guard expressions. Guard expressions are initiated by a | character followed by an expression that must evaluate into a boolean. Each pattern may have multiple guard expressions, each on a new line. For example, a function calculating body mass index could be defined like this: bmiTell bmi | bmi <= 18.5 = \"You're underweight, you emo, you!\" | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\" | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\" | true = \"You're a whale, congratulations!\" As can be seen, guards allow checking additional conditions that can't be captured by pattern itself, such as checking whether a number is in a range. Non-linear patterns - ability to use same variable in pattern multiple times \u00b6 Non-linear patterns are those that contain the same name in multiple places, for example: nonLinearHeadTailsTest head -| _ head -| _ = head nonLinearHeadTailsTest headOne -| _ headTwo -| _ = headOne + headTwo For example, calling this function: nonLinearHeadTailsTest [ 2 , 0 ] [ 3 , 0 ] Will yield 5 , because the first element in first and second argument must be the same.","title":"Pattern Matching"},{"location":"features/pattern-matching/#scalar-values-integer-float-byte-character-boolean-symbol","text":"Pattern matching for scalar values is super simple. The pattern looks is the value itself, for example: case expr of 5 -> do_something 6 -> do_something_else end","title":"Scalar values - integer, float, byte, character, boolean, symbol"},{"location":"features/pattern-matching/#tuples","text":"Pattern matching on tuples: case expr of ( : ok , value ) -> do_something value # value contains the second element of the tuple ( : error , message ) -> IO :: println message end","title":"Tuples"},{"location":"features/pattern-matching/#records","text":"Pattern matching on records is described in the section about Records.","title":"Records"},{"location":"features/pattern-matching/#underscore-pattern","text":"The underscore pattern _ will match any value.","title":"Underscore pattern"},{"location":"features/pattern-matching/#sequence-reverse-sequence-multiple-head-tails-their-combinations-in-patterns","text":"Sequence is a biderctional structure and can be easily pattern matched from either left or right side. Yona allows pattern matching on more than a single element as well:","title":"Sequence &amp; reverse sequence, multiple head &amp; tails &amp; their combinations in patterns"},{"location":"features/pattern-matching/#matching-sequence-on-the-beginning","text":"case [ 1 ] of 1 -| [] -> 2 [] -> 3 _ -> 9 end This code will result in 2 . Yona allows matching on more than just one element in the beginning: case [ 1 , 2 , 3 , 4 ] of 1 -| 2 -| [] -> 2 1 -| 2 -| tail -> tail [] -> 3 _ -> 9 end Will produce [3, 4] .","title":"Matching sequence on the beginning"},{"location":"features/pattern-matching/#matching-sequence-on-the-end","text":"case [ 1 ] of [] |- 1 -> 2 [] -> 3 _ -> 9 end This code will result in 2 .","title":"Matching sequence on the end"},{"location":"features/pattern-matching/#obtaining-a-remainer-of-a-sequnce","text":"case [ 1 , 2 , 3 ] of 1 -| [] -> 2 1 -| tail -> tail [] -> 3 _ -> 9 end This code will result in [2, 3] . This could also be done from the other end of the sequence, using |- operator instead (and reversing head/tails sections).","title":"Obtaining a remainer of a sequnce"},{"location":"features/pattern-matching/#matching-a-sequence-elements","text":"case arg of [] -> 3 [ 1 , second , 3 ] -> second _ -> 9 end Will produce 2 .","title":"Matching a sequence elements"},{"location":"features/pattern-matching/#matching-strings","text":"Since strings are sequences of characters, they can be pattern matched on as such. Alternatively string literals may be used as well, or any combination of the two. For example: case \"hello there\" of 'h' -| 'e' -| _ |- 'r' |- 'e' -> 0 _ -> 1 end Which will produce a 0 . Another example: case [ 'a' , 'b' , 'c' ] of h -| \"bc\" -> h _ -> 1 end Which produces an 'a' .","title":"Matching strings"},{"location":"features/pattern-matching/#dictionary-patterns","text":"Dictionaries can be matched on both keys and values. Example: case { \"a\" = 1 , \"b\" = 2 } of { \"b\" = 3 } -> 3 { \"a\" = 1 , \"b\" = bb } -> bb _ -> 9 end This will result in 2 .","title":"Dictionary patterns"},{"location":"features/pattern-matching/#as-patterns","text":"Sometimes it can be useful to name a collection (sequence, set or dictionary) or a record in a pattern for later use. For example when matching on a record type, but ignoring all the fields. This can be done using @ syntax in Yona: let mod = module TestMod exports testfun as record TestRecord = ( argone , argtwo ) testfun = case TestRecord ( argone = 1 , argtwo = 2 ) of 2 -> 0 x @ TestRecord -> x . argone _ -> 2 end end in mod :: testfun This slightly with an inlined module definition more complex example will produce 1 . Remember that records exist on a module level only.","title":"\"As\" patterns"},{"location":"features/pattern-matching/#let-expression-patterns","text":"let expression allows using patterns on the left side of its assignments. In that way it is not necessary to use case expression explicitly.","title":"let expression patterns"},{"location":"features/pattern-matching/#do-expression-patterns","text":"do expression similarly to let expressions allows defining aliases, and they can be patterns on the left side. Unlike let expression, do expression does not require value assignment, but still allows it. For example: do ( one , _ ) = ( 1 , :unused ) IO :: println one two = 2 one + two end Which will result in 3 after 1 is printed.","title":"* do expression patterns"},{"location":"features/pattern-matching/#case-patterns","text":"This is THE pattern matching expression. It maches a value against a list of patterns and executes the expression of the matching pattern.","title":"case patterns"},{"location":"features/pattern-matching/#function-lambda-patterns","text":"Functions and lambdas may be defined using patterns as explained in the section about functions. The only limitation of the lambda definitions, is that they may only contain one pattern. This is not used much for control flow, but still useful for deconstructing some data structures. If lambda needs to pattern match multiple patterns, either define it as a named function, or use case expression.","title":"Function &amp; lambda patterns"},{"location":"features/pattern-matching/#guard-expressions","text":"Patterns may be enhanced further with guard expressions. Guard expressions are initiated by a | character followed by an expression that must evaluate into a boolean. Each pattern may have multiple guard expressions, each on a new line. For example, a function calculating body mass index could be defined like this: bmiTell bmi | bmi <= 18.5 = \"You're underweight, you emo, you!\" | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\" | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\" | true = \"You're a whale, congratulations!\" As can be seen, guards allow checking additional conditions that can't be captured by pattern itself, such as checking whether a number is in a range.","title":"Guard expressions"},{"location":"features/pattern-matching/#non-linear-patterns-ability-to-use-same-variable-in-pattern-multiple-times","text":"Non-linear patterns are those that contain the same name in multiple places, for example: nonLinearHeadTailsTest head -| _ head -| _ = head nonLinearHeadTailsTest headOne -| _ headTwo -| _ = headOne + headTwo For example, calling this function: nonLinearHeadTailsTest [ 2 , 0 ] [ 3 , 0 ] Will yield 5 , because the first element in first and second argument must be the same.","title":"Non-linear patterns - ability to use same variable in pattern multiple times"},{"location":"features/polyglot/","text":"Yona allows interoperability with other languages on GraalVM through the Polyglot APIs . Built-in function eval \u00b6 First form of interoperability with other scripting languages on GraalVM is supported by function eval . This function takes two arguments, first is the symbol of a language, such as :yona , :js or :python and the second argument is a string of the expression to be evaluated in this language. Example: eval : yona \"raise :test \\\" test msg \\\" \" Java interop \u00b6 Interoperability with Java is an important feature in Yona and allows calling Java code directly from Yona and vice-versa. In order to call Yona code from Java, one must build a GraalVM Polyglot context and then evaluate a Yona source using this context: import org.graalvm.polyglot.Context ; import org.graalvm.polyglot.Value ; Context context = Context . newBuilder (). build (); Value returnValue = context . eval ( \"yona\" , \"5 + 3\" ); Type-conversions, constructing objects and calling methods \u00b6 Yona API for calling code in Java consists of two modules: Java - for instantiating new objects, checking instance type of an object, raising Java exceptions and casting Java objects java\\Types - for converting Yona types to Java types (for example Yona contains only 64bit integers, so they need to be converted to Java integers when calling a Java method that expects an integer. Same for double vs float. Simple example to create a BigInteger in Yona and then check that it is actually of BigInteger type: let type = Java :: type \"java.math.BigInteger\" instance = Java :: new type [ \"50\" ] in Java :: instanceof instance type Automatic conversions \u00b6 Yona has only one integer type (which is actually Java long) and only one float type (Java double). Yona cannot safely map these into Java types automatically. As Yona is dynamically typed, there is simply no way for Yona to know that you're trying to call a Java function expecting an integer and not a long for example. Therefore such automatic conversions do not really happen, and when calling a Java function, expecting a Java integer, you must manually convert this using Java\\Types::to_int , or Java\\Types::to_float respectively. More details in the documentation for that module . On the opposite side of the contract - returning Java values to Yona, following conversions are applied: null is represented as () Java array is represented as a sequence Java int (32-bit) is represented as a Yona int (64-bit) Java float (32-bit) is represented as a Yona double (64-bit) CharSequence is represented as Yona string Java char (UTF-16) is represented as Yona char (UTF-8) all other types which are shared by both Java and Yona, such as boolean , byte , long , double , those are kept as they are otherwise objects are wrapped as Yona native objects Calling methods on an object \u00b6 Yona allows using module call operator :: to be used to call object methods as well. This is shown in the following example for multiplying two BigInteger s: let type = Java :: type \"java.math.BigInteger\" big_two = Java :: new type [ \"2\" ] big_three = Java :: new type [ \"3\" ] result = big_two :: multiply big_three # calling a method ` multiply ` on object of type BigInteger . in result :: longValue Calling static methods in Java \u00b6 Static methods may be called just as easily from Yona: ( java \\ util \\ Collections :: singletonList 5 ) :: get ( java \\ Types :: to_int 0 ) Java static methods can be easily called from Yona, as if it were a Yona module/function. Handling Java exceptions \u00b6 Raising a Java exception from Yona is possible thanks to function Java::throw : try let type = Java :: type \"java.lang.ArithmeticException\" error = Java :: new type [ \"testing error\" ] in Java :: throw error catch ( : java , error_msg , _ ) -> error_msg # \"java.lang.ArithmeticException: testing error\" will be the result end The example above shows how to throw and catch Java exceptions in Yona code. Limitations of Polyglot APIs and other notes \u00b6 Java interop is implemented via Java reflection. This may be an issue when using native image built version of Yona interpreter. Currying on Java static function/method calls works with the same semantics as for Yona functions. Therefore, one may create a curried Java method simply by not passing all the necessary arguments to method calls. Java methods are resolved by names only. Since Yona is a dynamically typed language, Yona simply doesn't have the knowledge to determine the correct method otherwise. It cannot even utilize the number of arguments, because the method call may be curried. Therefore it picks the first method of the given name and tries to use that. Exceptions related to Polyglot APIs in Yona have a symbol of :polyglot .","title":"Polyglot"},{"location":"features/polyglot/#built-in-function-eval","text":"First form of interoperability with other scripting languages on GraalVM is supported by function eval . This function takes two arguments, first is the symbol of a language, such as :yona , :js or :python and the second argument is a string of the expression to be evaluated in this language. Example: eval : yona \"raise :test \\\" test msg \\\" \"","title":"Built-in function eval"},{"location":"features/polyglot/#java-interop","text":"Interoperability with Java is an important feature in Yona and allows calling Java code directly from Yona and vice-versa. In order to call Yona code from Java, one must build a GraalVM Polyglot context and then evaluate a Yona source using this context: import org.graalvm.polyglot.Context ; import org.graalvm.polyglot.Value ; Context context = Context . newBuilder (). build (); Value returnValue = context . eval ( \"yona\" , \"5 + 3\" );","title":"Java interop"},{"location":"features/polyglot/#type-conversions-constructing-objects-and-calling-methods","text":"Yona API for calling code in Java consists of two modules: Java - for instantiating new objects, checking instance type of an object, raising Java exceptions and casting Java objects java\\Types - for converting Yona types to Java types (for example Yona contains only 64bit integers, so they need to be converted to Java integers when calling a Java method that expects an integer. Same for double vs float. Simple example to create a BigInteger in Yona and then check that it is actually of BigInteger type: let type = Java :: type \"java.math.BigInteger\" instance = Java :: new type [ \"50\" ] in Java :: instanceof instance type","title":"Type-conversions, constructing objects and calling methods"},{"location":"features/polyglot/#automatic-conversions","text":"Yona has only one integer type (which is actually Java long) and only one float type (Java double). Yona cannot safely map these into Java types automatically. As Yona is dynamically typed, there is simply no way for Yona to know that you're trying to call a Java function expecting an integer and not a long for example. Therefore such automatic conversions do not really happen, and when calling a Java function, expecting a Java integer, you must manually convert this using Java\\Types::to_int , or Java\\Types::to_float respectively. More details in the documentation for that module . On the opposite side of the contract - returning Java values to Yona, following conversions are applied: null is represented as () Java array is represented as a sequence Java int (32-bit) is represented as a Yona int (64-bit) Java float (32-bit) is represented as a Yona double (64-bit) CharSequence is represented as Yona string Java char (UTF-16) is represented as Yona char (UTF-8) all other types which are shared by both Java and Yona, such as boolean , byte , long , double , those are kept as they are otherwise objects are wrapped as Yona native objects","title":"Automatic conversions"},{"location":"features/polyglot/#calling-methods-on-an-object","text":"Yona allows using module call operator :: to be used to call object methods as well. This is shown in the following example for multiplying two BigInteger s: let type = Java :: type \"java.math.BigInteger\" big_two = Java :: new type [ \"2\" ] big_three = Java :: new type [ \"3\" ] result = big_two :: multiply big_three # calling a method ` multiply ` on object of type BigInteger . in result :: longValue","title":"Calling methods on an object"},{"location":"features/polyglot/#calling-static-methods-in-java","text":"Static methods may be called just as easily from Yona: ( java \\ util \\ Collections :: singletonList 5 ) :: get ( java \\ Types :: to_int 0 ) Java static methods can be easily called from Yona, as if it were a Yona module/function.","title":"Calling static methods in Java"},{"location":"features/polyglot/#handling-java-exceptions","text":"Raising a Java exception from Yona is possible thanks to function Java::throw : try let type = Java :: type \"java.lang.ArithmeticException\" error = Java :: new type [ \"testing error\" ] in Java :: throw error catch ( : java , error_msg , _ ) -> error_msg # \"java.lang.ArithmeticException: testing error\" will be the result end The example above shows how to throw and catch Java exceptions in Yona code.","title":"Handling Java exceptions"},{"location":"features/polyglot/#limitations-of-polyglot-apis-and-other-notes","text":"Java interop is implemented via Java reflection. This may be an issue when using native image built version of Yona interpreter. Currying on Java static function/method calls works with the same semantics as for Yona functions. Therefore, one may create a curried Java method simply by not passing all the necessary arguments to method calls. Java methods are resolved by names only. Since Yona is a dynamically typed language, Yona simply doesn't have the knowledge to determine the correct method otherwise. It cannot even utilize the number of arguments, because the method call may be curried. Therefore it picks the first method of the given name and tries to use that. Exceptions related to Polyglot APIs in Yona have a symbol of :polyglot .","title":"Limitations of Polyglot APIs and other notes"},{"location":"features/resource-management/","text":"Yona provides a specialized infrastructure for managing resources, including their initialization and finalization, with guaranteed ordering and error handling. This feature is called context managers and it allows for generic, extensible management of local contexts. Context managers are used in conjunction with the with expression . Context Managers \u00b6 Context managers provide the necessary gear for dealing with resource management is a structured way, that can be used together with the with expression . They provide a way for Yona to initialize and finalize resources. Resources may be explicitly or implicitly named direct access within the scope of the with expression. Module context\\Local provides functions for implementing custom context managers. Builtin modules, such as STM or File implement context managers as well. Context managers store their data in a local dictionary, so that they can be used from any threads (this is transparent for programmers, who need not to be aware of this actually). Context manager is a triple of (name, wrapper, data) , where: name is the default name of the alias, used as a key in the local context dictionary. wrapper wrapper is a 2-arg function - taking the context manager tuple and a callback that is called from within this wrapper function and of which result is returned as a result of this wrapper. The wrapper can perform initialization and finalization of resources around calling the callback. data is the actual data, such as transaction object, file object or whatever other resource data to be managed by the context manager. Lifecycle of Context Managers \u00b6 Context manager is executed in this order: the context manager tuple is stored to the local context dictionary the wrapper function is executed, expected to initialize necessary resources, then call the callback passed into this function and finally resources get disposed after they've been used if body expression raises an exception, the leave function is still called regardless Handling errors \u00b6 Whether an exception is raised or not within the context manager execution is not important for its lifecycle. Context managers ensure that proper initialization and finalization of resources always takes place and for this reason they are the recommended way for handling this sort of thing Daemon Context Management \u00b6 Context managers provide means to manage resources in a consistent and safe way. Just like any other constructions in Yona, the with expression produces a return value, that of its body. Sometimes it may be desired not to await this result but still take advantage of the automatic resource management provided by the with expression. This is typically the case when the context manager is provided per connection. In this case the calling expression would be limited to handling only one connection at a time. In these situations it is useful to move the body expression processing to the background and \"forget\" about it. This can be achieved by putting a daemon keyword after the with keyword. For more information about the syntax, see the syntax guide for the with expression . The result of the with daemon expression is therefore () , resources will be properly released once the body expression evaluation finishes, nevertheless.","title":"Resource Management"},{"location":"features/resource-management/#context-managers","text":"Context managers provide the necessary gear for dealing with resource management is a structured way, that can be used together with the with expression . They provide a way for Yona to initialize and finalize resources. Resources may be explicitly or implicitly named direct access within the scope of the with expression. Module context\\Local provides functions for implementing custom context managers. Builtin modules, such as STM or File implement context managers as well. Context managers store their data in a local dictionary, so that they can be used from any threads (this is transparent for programmers, who need not to be aware of this actually). Context manager is a triple of (name, wrapper, data) , where: name is the default name of the alias, used as a key in the local context dictionary. wrapper wrapper is a 2-arg function - taking the context manager tuple and a callback that is called from within this wrapper function and of which result is returned as a result of this wrapper. The wrapper can perform initialization and finalization of resources around calling the callback. data is the actual data, such as transaction object, file object or whatever other resource data to be managed by the context manager.","title":"Context Managers"},{"location":"features/resource-management/#lifecycle-of-context-managers","text":"Context manager is executed in this order: the context manager tuple is stored to the local context dictionary the wrapper function is executed, expected to initialize necessary resources, then call the callback passed into this function and finally resources get disposed after they've been used if body expression raises an exception, the leave function is still called regardless","title":"Lifecycle of Context Managers"},{"location":"features/resource-management/#handling-errors","text":"Whether an exception is raised or not within the context manager execution is not important for its lifecycle. Context managers ensure that proper initialization and finalization of resources always takes place and for this reason they are the recommended way for handling this sort of thing","title":"Handling errors"},{"location":"features/resource-management/#daemon-context-management","text":"Context managers provide means to manage resources in a consistent and safe way. Just like any other constructions in Yona, the with expression produces a return value, that of its body. Sometimes it may be desired not to await this result but still take advantage of the automatic resource management provided by the with expression. This is typically the case when the context manager is provided per connection. In this case the calling expression would be limited to handling only one connection at a time. In these situations it is useful to move the body expression processing to the background and \"forget\" about it. This can be achieved by putting a daemon keyword after the with keyword. For more information about the syntax, see the syntax guide for the with expression . The result of the with daemon expression is therefore () , resources will be properly released once the body expression evaluation finishes, nevertheless.","title":"Daemon Context Management"},{"location":"getting_started/installation/","text":"Running as a Docker container: \u00b6 The simplest way to use Yona is to run it in a Docker container. Please see the instructions at Docker Hub . IDEA Plugin \u00b6 Set up IDEA Plugin for Yona, which provides syntax highlighting and syntax validation. Running within local installation of GraalVM \u00b6 Requirements \u00b6 Any OS capable of running GraalVM GraalVM 21.2.0 - Java 16 Ensure JAVA_HOME environment variable points to the root of your GraalVM installation Ensure PATH contains your GraalVM root folder + /bin Installation Instructions \u00b6 It is possible to run Yona locally, whether for play purposes or development of new features. Install GraalVM \u00b6 These instructions set up GraalVM, required environment variables, and install the Yona component into GraalVM. export JAVA_HOME = $HOME /jdk PATH = $JAVA_HOME /bin: $JAVA_HOME /graalvm/bin: $PATH GRAALVM_VERSION = \"21.3.0\" GRAALVM_JAVA_VERSION = \"17\" wget -O $HOME /jdk.tar.gz https://github.com/graalvm/graalvm-ce-builds/releases/download/vm- $GRAALVM_VERSION /graalvm-ce-java $GRAALVM_JAVA_VERSION -linux-amd64- $GRAALVM_VERSION .tar.gz mkdir $JAVA_HOME && tar -xzf $HOME /jdk.tar.gz -C $JAVA_HOME --strip-components = 1 gu install -ur https://github.com/yona-lang/yona/releases/latest/download/yona-component.jar You can see Yona releases at GitHub releases page. Run yona interpreter \u00b6 Yona comes as a GraalVM component, with two executables: yona - default interpreter, supporting all GraalVM features, such as Polyglot usage, etc. (unsupported at the moment) yonanative - ahead-of-time compiled interpreter that offers faster startup, though may be slower executing longer running programs. Note that yonanative currently works only on 64-bit Linux. Both executables currently accept only a filename as an argument. This file is then executed using the interpreter. Optionally, if no file is provided, the interpreter will expect an input on the standard input when ran. Ctrl-D marks the end of the input in this case. Tip There are many tests available in the Yona repository that can serve as a good starting point for writing some programs in Yona. Interpreter logging \u00b6 Logging can be enabled to debug certain types of issues, for example related to module loading. To do so, make sure your interpreter(either yona or yonanative ) is ran with: yona --log.yona.level = CONFIG or additionally you can try increasing the log level all the way down to FINE , FINER or even FINEST . Another option is to use -v / --verbose flag, which switches the log level to FINE . Local development setup \u00b6 These instructions are for setting up a local development environment. Currently Debian 10 is the only verified platform (though, any Linux that runs GraalVM should in theory work). Build requirements - Debian \u00b6 sudo apt install build-essential zlib1g zlib1g-dev Download and install Maven \u00b6 Download Maven from their site . Then unpack it somewhere and make sure maven/bin path is added to $PATH . Getting GraalVM \u00b6 mvn package -DskipTests = true -Dmaven.javadoc.skip = true -B -V Running Yona \u00b6 After cloning the repository, Yona interpreter can be run simply by: ./yona <filename.yona>","title":"Installation"},{"location":"getting_started/installation/#running-as-a-docker-container","text":"The simplest way to use Yona is to run it in a Docker container. Please see the instructions at Docker Hub .","title":"Running as a Docker container:"},{"location":"getting_started/installation/#idea-plugin","text":"Set up IDEA Plugin for Yona, which provides syntax highlighting and syntax validation.","title":"IDEA Plugin"},{"location":"getting_started/installation/#running-within-local-installation-of-graalvm","text":"","title":"Running within local installation of GraalVM"},{"location":"getting_started/installation/#requirements","text":"Any OS capable of running GraalVM GraalVM 21.2.0 - Java 16 Ensure JAVA_HOME environment variable points to the root of your GraalVM installation Ensure PATH contains your GraalVM root folder + /bin","title":"Requirements"},{"location":"getting_started/installation/#installation-instructions","text":"It is possible to run Yona locally, whether for play purposes or development of new features.","title":"Installation Instructions"},{"location":"getting_started/installation/#install-graalvm","text":"These instructions set up GraalVM, required environment variables, and install the Yona component into GraalVM. export JAVA_HOME = $HOME /jdk PATH = $JAVA_HOME /bin: $JAVA_HOME /graalvm/bin: $PATH GRAALVM_VERSION = \"21.3.0\" GRAALVM_JAVA_VERSION = \"17\" wget -O $HOME /jdk.tar.gz https://github.com/graalvm/graalvm-ce-builds/releases/download/vm- $GRAALVM_VERSION /graalvm-ce-java $GRAALVM_JAVA_VERSION -linux-amd64- $GRAALVM_VERSION .tar.gz mkdir $JAVA_HOME && tar -xzf $HOME /jdk.tar.gz -C $JAVA_HOME --strip-components = 1 gu install -ur https://github.com/yona-lang/yona/releases/latest/download/yona-component.jar You can see Yona releases at GitHub releases page.","title":"Install GraalVM"},{"location":"getting_started/installation/#run-yona-interpreter","text":"Yona comes as a GraalVM component, with two executables: yona - default interpreter, supporting all GraalVM features, such as Polyglot usage, etc. (unsupported at the moment) yonanative - ahead-of-time compiled interpreter that offers faster startup, though may be slower executing longer running programs. Note that yonanative currently works only on 64-bit Linux. Both executables currently accept only a filename as an argument. This file is then executed using the interpreter. Optionally, if no file is provided, the interpreter will expect an input on the standard input when ran. Ctrl-D marks the end of the input in this case. Tip There are many tests available in the Yona repository that can serve as a good starting point for writing some programs in Yona.","title":"Run yona interpreter"},{"location":"getting_started/installation/#interpreter-logging","text":"Logging can be enabled to debug certain types of issues, for example related to module loading. To do so, make sure your interpreter(either yona or yonanative ) is ran with: yona --log.yona.level = CONFIG or additionally you can try increasing the log level all the way down to FINE , FINER or even FINEST . Another option is to use -v / --verbose flag, which switches the log level to FINE .","title":"Interpreter logging"},{"location":"getting_started/installation/#local-development-setup","text":"These instructions are for setting up a local development environment. Currently Debian 10 is the only verified platform (though, any Linux that runs GraalVM should in theory work).","title":"Local development setup"},{"location":"getting_started/installation/#build-requirements-debian","text":"sudo apt install build-essential zlib1g zlib1g-dev","title":"Build requirements - Debian"},{"location":"getting_started/installation/#download-and-install-maven","text":"Download Maven from their site . Then unpack it somewhere and make sure maven/bin path is added to $PATH .","title":"Download and install Maven"},{"location":"getting_started/installation/#getting-graalvm","text":"mvn package -DskipTests = true -Dmaven.javadoc.skip = true -B -V","title":"Getting GraalVM"},{"location":"getting_started/installation/#running-yona","text":"After cloning the repository, Yona interpreter can be run simply by: ./yona <filename.yona>","title":"Running Yona"},{"location":"getting_started/release-notes/","text":"IDEA Plugin 0.1.0 - September 2 nd 2021 \u00b6 structure view - showing modules, functions and records navigate to declaration - within module and project create new Yona file from the menu search for functions via global search fixed missing icon for Yona files Yona 0.8.3-SNAPSHOT: \u00b6 GraalVM 21.2.0-java-16 is required now, see installation page for details terminal\\Colors , terminal\\colors\\Background and terminal\\colors\\Foreground : new standard library modules for terminal related functionality Time : new module for working with Time new function Seq::join for joining sequences of string with a separator Scheduler : new module for scheduling tasks Exception : new module for working with exceptions Random : new module for random number generation fixed issue with the JSON::generate not escaping quotes IDEA Plugin 0.0.4 - June 13 th 2021 \u00b6 fixed issues with syntax highlighting in string interpolation brace marcher commented support Yona 0.8.2-SNAPSHOT: \u00b6 TCP Socket Client , Server , Connection modules Updated Seq , Set and Dict to match Haskell's fold and reduce interface and also some new functions Stopwatch module Benchmarks and examples available in the source repository Improved REPL experience Deamon context managers GraalVM 21.1.0-java-16 is required now, see installation page for details Added ability to \"execute\" a module that exports a zero argument function called main Yona 0.8.1-SNAPSHOT: \u00b6 resource management STM module Regexp module IO module now containing println , read and readln functions REPL, with syntax highlighting, autocomplete, history, etc. GraalVM 20.3.0 is required now, see installation page for details IDEA Plugin 0.0.1 - June 17 th 2020 \u00b6 first public release available from JetBrains Marketplace basic syntax highlighting Yona 0.8.0: alpha version - May 25 th 2020 \u00b6 first public release release available from GiHub releases","title":"Release Notes"},{"location":"getting_started/release-notes/#idea-plugin-0.1.0","text":"structure view - showing modules, functions and records navigate to declaration - within module and project create new Yona file from the menu search for functions via global search fixed missing icon for Yona files","title":"IDEA Plugin 0.1.0 - September 2nd 2021"},{"location":"getting_started/release-notes/#yona-0.8.3","text":"GraalVM 21.2.0-java-16 is required now, see installation page for details terminal\\Colors , terminal\\colors\\Background and terminal\\colors\\Foreground : new standard library modules for terminal related functionality Time : new module for working with Time new function Seq::join for joining sequences of string with a separator Scheduler : new module for scheduling tasks Exception : new module for working with exceptions Random : new module for random number generation fixed issue with the JSON::generate not escaping quotes","title":"Yona 0.8.3-SNAPSHOT:"},{"location":"getting_started/release-notes/#idea-plugin-0.0.4","text":"fixed issues with syntax highlighting in string interpolation brace marcher commented support","title":"IDEA Plugin 0.0.4 - June 13th 2021"},{"location":"getting_started/release-notes/#yona-0.8.2","text":"TCP Socket Client , Server , Connection modules Updated Seq , Set and Dict to match Haskell's fold and reduce interface and also some new functions Stopwatch module Benchmarks and examples available in the source repository Improved REPL experience Deamon context managers GraalVM 21.1.0-java-16 is required now, see installation page for details Added ability to \"execute\" a module that exports a zero argument function called main","title":"Yona 0.8.2-SNAPSHOT:"},{"location":"getting_started/release-notes/#yona-0.8.1","text":"resource management STM module Regexp module IO module now containing println , read and readln functions REPL, with syntax highlighting, autocomplete, history, etc. GraalVM 20.3.0 is required now, see installation page for details","title":"Yona 0.8.1-SNAPSHOT:"},{"location":"getting_started/release-notes/#idea-plugin-0.0.1","text":"first public release available from JetBrains Marketplace basic syntax highlighting","title":"IDEA Plugin 0.0.1 - June 17th 2020"},{"location":"getting_started/release-notes/#yona-0.8.0","text":"first public release release available from GiHub releases","title":"Yona 0.8.0: alpha version - May 25th 2020"},{"location":"stdlib/dict/","text":"This module provides functions for manipulating Dictionaries. Dictionaries are immutable data structure containing unique pairs of key and value. Usage \u00b6 There is a special syntax to create an empty dictionary: {} . Dictionaries support special operators for adding elements or operations typical for dictionaries, such as unions or intersections etc. Folding a dictionary \u00b6 Folding a dictionary is a process of iterating over its key-value pairs while producing one result value. An example of a folding function could be a sum function, that iterates over all elements and adds all the values up, producing a single result. Functions foldl take 3 arguments: * 2-argument lambda (accumulator, (key, value)) returning a new value of an accumulator * initial value of the accumulator * dictionary to fold This example shows how to sum up a dictionary: Dict :: fold ( \\ acc ( key , value ) -> acc + value ) 0 { 'a' = 1 , 'b' = 2 , 'c' = 3 } Reducing a dictionary \u00b6 Reducing a dictionary means applying a transducer onto a dictionary. Transducers are a generic, high-level method for implementing operations over a data structure. Function reduce takes 2 arguments: * transducer * dictionary to reduce Example with a map transducer: Dict :: reduce ( Transducers :: map \\ val -> val * 2 ( 0 , \\ state val -> state + 1 , identity )) { 'a' = 1 , 'b' = 2 , 'c' = 3 } This example will produce 12 , as it sums up all the values doubled. Obtaining a length of a dictionary \u00b6 Function len returns a length of a dictionary: length = Dict :: len { 'a' = 1 , 'b' = 2 , 'c' = 3 } Looking up a value by a key \u00b6 Function lookup returns a value by the key, or () if not found. First argument is the second is the key and the second one is the dictionary. length = Dict :: lookup 'a' { 'a' = 1 , 'b' = 2 , 'c' = 3 } Building a dictionary from a sequence of tuples \u00b6 Function from_seq builds a dictionary from a sequence of tuples. Example: Dict :: from_seq [( 1 , 4 ), ( 2 , 5 ), ( 3 , 6 )] Will return {1 = 4, 2 = 5, 3 = 6} . Turning a dictionary to a sequence of tuples \u00b6 Function entries is the inverse operation of the from_seq function and it returns a sequence of tuples (key, value) for the provided dictionary. Example: Dict :: entries { 1 = 4 , 2 = 5 , 3 = 6 } Will return [(1, 4), (2, 5), (3, 6)] . Getting keys from the dictionary \u00b6 Function keys returns a set of all keys for the provided dictionary. Example: Dict :: keys { 1 = 4 , 2 = 5 , 3 = 6 } Will return {1, 2, 3} .","title":"Dict"},{"location":"stdlib/dict/#usage","text":"There is a special syntax to create an empty dictionary: {} . Dictionaries support special operators for adding elements or operations typical for dictionaries, such as unions or intersections etc.","title":"Usage"},{"location":"stdlib/dict/#folding-a-dictionary","text":"Folding a dictionary is a process of iterating over its key-value pairs while producing one result value. An example of a folding function could be a sum function, that iterates over all elements and adds all the values up, producing a single result. Functions foldl take 3 arguments: * 2-argument lambda (accumulator, (key, value)) returning a new value of an accumulator * initial value of the accumulator * dictionary to fold This example shows how to sum up a dictionary: Dict :: fold ( \\ acc ( key , value ) -> acc + value ) 0 { 'a' = 1 , 'b' = 2 , 'c' = 3 }","title":"Folding a dictionary"},{"location":"stdlib/dict/#reducing-a-dictionary","text":"Reducing a dictionary means applying a transducer onto a dictionary. Transducers are a generic, high-level method for implementing operations over a data structure. Function reduce takes 2 arguments: * transducer * dictionary to reduce Example with a map transducer: Dict :: reduce ( Transducers :: map \\ val -> val * 2 ( 0 , \\ state val -> state + 1 , identity )) { 'a' = 1 , 'b' = 2 , 'c' = 3 } This example will produce 12 , as it sums up all the values doubled.","title":"Reducing a dictionary"},{"location":"stdlib/dict/#obtaining-a-length-of-a-dictionary","text":"Function len returns a length of a dictionary: length = Dict :: len { 'a' = 1 , 'b' = 2 , 'c' = 3 }","title":"Obtaining a length of a dictionary"},{"location":"stdlib/dict/#looking-up-a-value-by-a-key","text":"Function lookup returns a value by the key, or () if not found. First argument is the second is the key and the second one is the dictionary. length = Dict :: lookup 'a' { 'a' = 1 , 'b' = 2 , 'c' = 3 }","title":"Looking up a value by a key"},{"location":"stdlib/dict/#building-a-dictionary-from-a-sequence-of-tuples","text":"Function from_seq builds a dictionary from a sequence of tuples. Example: Dict :: from_seq [( 1 , 4 ), ( 2 , 5 ), ( 3 , 6 )] Will return {1 = 4, 2 = 5, 3 = 6} .","title":"Building a dictionary from a sequence of tuples"},{"location":"stdlib/dict/#turning-a-dictionary-to-a-sequence-of-tuples","text":"Function entries is the inverse operation of the from_seq function and it returns a sequence of tuples (key, value) for the provided dictionary. Example: Dict :: entries { 1 = 4 , 2 = 5 , 3 = 6 } Will return [(1, 4), (2, 5), (3, 6)] .","title":"Turning a dictionary to a sequence of tuples"},{"location":"stdlib/dict/#getting-keys-from-the-dictionary","text":"Function keys returns a set of all keys for the provided dictionary. Example: Dict :: keys { 1 = 4 , 2 = 5 , 3 = 6 } Will return {1, 2, 3} .","title":"Getting keys from the dictionary"},{"location":"stdlib/exception/","text":"Exception handling related functionality. Usage \u00b6 Pretty printing exception stack trace \u00b6 Function pretty_print_stacktrace accepts a stacktrace (third element of a caught exception tuple, see exceptions syntax ). It produces a string, with lines, each representing one stack frame, first being the most recent one. Example: try expression catch ( : badarg , error_msg , stacktrace ) -> Exception :: pretty_print_stacktrace stacktrace |> IO :: println_err end","title":"Exception"},{"location":"stdlib/exception/#usage","text":"","title":"Usage"},{"location":"stdlib/exception/#pretty-printing-exception-stack-trace","text":"Function pretty_print_stacktrace accepts a stacktrace (third element of a caught exception tuple, see exceptions syntax ). It produces a string, with lines, each representing one stack frame, first being the most recent one. Example: try expression catch ( : badarg , error_msg , stacktrace ) -> Exception :: pretty_print_stacktrace stacktrace |> IO :: println_err end","title":"Pretty printing exception stack trace"},{"location":"stdlib/file/","text":"This module provides functions for reading, writing and otherwise manipulating files. Usage \u00b6 All file access is non-blocking and asynchronous. Behind the courtains, file operations use AsynchronousFileChannel . Files can be worked in either text or binary mode. Text mode anticipates that file is encoded in UTF-8 encoding, whereas binary file may contain any contents. Opening a file \u00b6 File must be opened before used. Function open takes a path and set of file \"modes\" as arguments and returns a file handle. This handle is actually a tuple with several items, that should not be accessed directly, but instead handled to functions operating on a file, from this module. Opening file for reading, in a text mode, for example: fh = File :: open \"test.txt\" { : read } Available modes (for further details, refer to Java's StandardOpenOption ): Mode Description :read Open for read access. :write Open for write access. :append If the file is opened for :write access then bytes will be written to the end of the file rather than the beginning. :truncate_existing If the file already exists and it is opened for :write access, then its length is truncated to 0. :create Create a new file if it does not exist. :create_new Create a new file, failing if the file already exists. :delete_on_close Delete on close. :sparse Sparse file. :sync Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. :dsync Requires that every update to the file's content be written synchronously to the underlying storage device. Opening and closing files with context managers \u00b6 Context managers are the recommended way of dealing with files. They provide error handling, such that the user does not need to worry about properly closing files in all situations. Using files as context managers is really simple, since it requires nothing more than the open function, that already returns a context manager! Therefore using files in this way is as simple as writing: with File :: open \"File.txt\" { : read } as file File :: read_lines file end There is no need to explicitly close files when using context managers. Deleting a file \u00b6 Function to delete an existing file takes a file handle a returns a () . File :: delete fh Seeking to a position in a file \u00b6 Seeking to a position takes a file handle, new position (integer) and returns an updated file handle: new_fh = File :: seek fh position Creating a temporary file \u00b6 In order to create a temporary file in a system temp folder, pass a prefix (string), suffix (string) and a set of file modes. Function returns a new handle, with a newly created temporary file, opened using the specified file modes. The file will be kept after use, unless :delete_on_close option was specified. fh = File :: make_temp \"prefix\" \"suffix\" { : write } Obtaining a path from a file handle \u00b6 It can be useful to obtain a path from a file handle, for example when working with temporary files. Path is a string. path = File :: path fh Listing files in a directory \u00b6 To list files in a directory, use function list_dir . Note that this function does not recurse over nested subfolders. files = File :: list_dir \"./\" Reading file - line mode \u00b6 File can be read either as a whole, or in lines (provided that it is a text file). Lines may be separated by either \\n or \\r\\n . Function read_line expects a file handle, and returns either :eof if the whole file was already read, or a triple of: * :ok * body - either a byte sequence or a string, depending on a mode file is opened in * new file handle Counting lines in a file can be implemented for example this way: count_file_lines file = read_lines fh 0 read_lines fh acc = case File :: read_line fh of ( : ok , _ , new_fh ) -> read_lines new_fh ( acc + 1 ) : eof -> acc end Function read_all_lines will count the number of lines in a file. For convenience, module File comes with a function read_lines which takes a file handle and returns a sequence of all lines. Example: lines = File :: read_lines fh Reading file - all at once \u00b6 To read the whole file, use function read . This function returns a sequence containing the contents of the file (either as a string, or sequence of bytes, depending on the mode in which the file is opened). file_contents = File :: read file Writing to file \u00b6 Writing to file requires a file to be opened in a :write mode. The write functin expects a file handle and a sequence (string or a byte sequence) to be written to the file. The sequence will be written at whatever position the file handle is currently pointing to. File :: write temp_file \"hello world\"","title":"File"},{"location":"stdlib/file/#usage","text":"All file access is non-blocking and asynchronous. Behind the courtains, file operations use AsynchronousFileChannel . Files can be worked in either text or binary mode. Text mode anticipates that file is encoded in UTF-8 encoding, whereas binary file may contain any contents.","title":"Usage"},{"location":"stdlib/file/#opening-a-file","text":"File must be opened before used. Function open takes a path and set of file \"modes\" as arguments and returns a file handle. This handle is actually a tuple with several items, that should not be accessed directly, but instead handled to functions operating on a file, from this module. Opening file for reading, in a text mode, for example: fh = File :: open \"test.txt\" { : read } Available modes (for further details, refer to Java's StandardOpenOption ): Mode Description :read Open for read access. :write Open for write access. :append If the file is opened for :write access then bytes will be written to the end of the file rather than the beginning. :truncate_existing If the file already exists and it is opened for :write access, then its length is truncated to 0. :create Create a new file if it does not exist. :create_new Create a new file, failing if the file already exists. :delete_on_close Delete on close. :sparse Sparse file. :sync Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. :dsync Requires that every update to the file's content be written synchronously to the underlying storage device.","title":"Opening a file"},{"location":"stdlib/file/#opening-closing","text":"Context managers are the recommended way of dealing with files. They provide error handling, such that the user does not need to worry about properly closing files in all situations. Using files as context managers is really simple, since it requires nothing more than the open function, that already returns a context manager! Therefore using files in this way is as simple as writing: with File :: open \"File.txt\" { : read } as file File :: read_lines file end There is no need to explicitly close files when using context managers.","title":"Opening and closing files with context managers"},{"location":"stdlib/file/#deleting-a-file","text":"Function to delete an existing file takes a file handle a returns a () . File :: delete fh","title":"Deleting a file"},{"location":"stdlib/file/#seeking-to-a-position-in-a-file","text":"Seeking to a position takes a file handle, new position (integer) and returns an updated file handle: new_fh = File :: seek fh position","title":"Seeking to a position in a file"},{"location":"stdlib/file/#creating-a-temporary-file","text":"In order to create a temporary file in a system temp folder, pass a prefix (string), suffix (string) and a set of file modes. Function returns a new handle, with a newly created temporary file, opened using the specified file modes. The file will be kept after use, unless :delete_on_close option was specified. fh = File :: make_temp \"prefix\" \"suffix\" { : write }","title":"Creating a temporary file"},{"location":"stdlib/file/#obtaining-a-path-from-a-file-handle","text":"It can be useful to obtain a path from a file handle, for example when working with temporary files. Path is a string. path = File :: path fh","title":"Obtaining a path from a file handle"},{"location":"stdlib/file/#listing-files-in-a-directory","text":"To list files in a directory, use function list_dir . Note that this function does not recurse over nested subfolders. files = File :: list_dir \"./\"","title":"Listing files in a directory"},{"location":"stdlib/file/#read-lines","text":"File can be read either as a whole, or in lines (provided that it is a text file). Lines may be separated by either \\n or \\r\\n . Function read_line expects a file handle, and returns either :eof if the whole file was already read, or a triple of: * :ok * body - either a byte sequence or a string, depending on a mode file is opened in * new file handle Counting lines in a file can be implemented for example this way: count_file_lines file = read_lines fh 0 read_lines fh acc = case File :: read_line fh of ( : ok , _ , new_fh ) -> read_lines new_fh ( acc + 1 ) : eof -> acc end Function read_all_lines will count the number of lines in a file. For convenience, module File comes with a function read_lines which takes a file handle and returns a sequence of all lines. Example: lines = File :: read_lines fh","title":"Reading file - line mode"},{"location":"stdlib/file/#reading-file-all-at-once","text":"To read the whole file, use function read . This function returns a sequence containing the contents of the file (either as a string, or sequence of bytes, depending on the mode in which the file is opened). file_contents = File :: read file","title":"Reading file - all at once"},{"location":"stdlib/file/#writing-to-file","text":"Writing to file requires a file to be opened in a :write mode. The write functin expects a file handle and a sequence (string or a byte sequence) to be written to the file. The sequence will be written at whatever position the file handle is currently pointing to. File :: write temp_file \"hello world\"","title":"Writing to file"},{"location":"stdlib/io/","text":"This module provides basic input/output functionality. Printing to standard output \u00b6 Function readln reads a line from the standard input. This function is non-blocking and may throw and :ioerror if there is an I/O error. Usage: line = readln Reading a character from the standard input \u00b6 Function read reads a single character from the standard input. This function is non-blocking and may throw and :ioerror if there is an I/O error. Usage: character = read Reading a line from the standard input \u00b6 Function readln reads a line from the standard input. This function is non-blocking and may throw and :ioerror if there is an I/O error. Usage: line = readln","title":"IO"},{"location":"stdlib/io/#printing-to-standard-output","text":"Function readln reads a line from the standard input. This function is non-blocking and may throw and :ioerror if there is an I/O error. Usage: line = readln","title":"Printing to standard output"},{"location":"stdlib/io/#reading-a-character-from-the-standard-input","text":"Function read reads a single character from the standard input. This function is non-blocking and may throw and :ioerror if there is an I/O error. Usage: character = read","title":"Reading a character from the standard input"},{"location":"stdlib/io/#reading-a-line-from-the-standard-input","text":"Function readln reads a line from the standard input. This function is non-blocking and may throw and :ioerror if there is an I/O error. Usage: line = readln","title":"Reading a line from the standard input"},{"location":"stdlib/java/","text":"This module provides important functions for interoperability with Java . Usage \u00b6 This modules allows Java executing specific code, such as instantiating a class, casting to another type, checking whether a value is an instance of a class, or throwing Java exceptions. Representing a Java type \u00b6 Function type takes a string - a fully qualified name of a Java class and creates a Yona representation of given class. This value can be used to create new instances of this type. Example: big_integer = Java :: type \"java.math.BigInteger\" Creating a new instance of a Java class \u00b6 Function new takes a Java type as the first argument and a sequence of arguments that are passed to the first matching constructor of the given type. Matching in this case means having same number of arguments, types are not checked. Example: big_integer_two = Java :: new big_integer [ \"2\" ] Throwing Java exceptions \u00b6 Function throw may be used to throw a Java exception. It takes an object as an argument and this object must be a Java Throwable . Example: let type = Java :: type \"java.lang.ArithmeticException\" error = Java :: new type [ \"testing error\" ] in Java :: throw error Checking whether an object is instance of \u00b6 Function instanceof takes an object and a type as arguments and returns a boolean if the object is instance of the provided type. Example: let type = Java :: type \"java.math.BigInteger\" instance = Java :: new type [ \"50\" ] in Java :: instanceof instance type Casting an object to another type \u00b6 Function case takes an object and a type to which the object should be casted to. Example: let type = Java :: type \"java.math.BigInteger\" instance = Java :: new type [ \"50\" ] cast_to_type = Java :: type \"java.lang.Number\" in Java :: cast instance cast_to_type","title":"Java"},{"location":"stdlib/java/#usage","text":"This modules allows Java executing specific code, such as instantiating a class, casting to another type, checking whether a value is an instance of a class, or throwing Java exceptions.","title":"Usage"},{"location":"stdlib/java/#representing-a-java-type","text":"Function type takes a string - a fully qualified name of a Java class and creates a Yona representation of given class. This value can be used to create new instances of this type. Example: big_integer = Java :: type \"java.math.BigInteger\"","title":"Representing a Java type"},{"location":"stdlib/java/#creating-a-new-instance-of-a-java-class","text":"Function new takes a Java type as the first argument and a sequence of arguments that are passed to the first matching constructor of the given type. Matching in this case means having same number of arguments, types are not checked. Example: big_integer_two = Java :: new big_integer [ \"2\" ]","title":"Creating a new instance of a Java class"},{"location":"stdlib/java/#throwing-java-exceptions","text":"Function throw may be used to throw a Java exception. It takes an object as an argument and this object must be a Java Throwable . Example: let type = Java :: type \"java.lang.ArithmeticException\" error = Java :: new type [ \"testing error\" ] in Java :: throw error","title":"Throwing Java exceptions"},{"location":"stdlib/java/#checking-whether-an-object-is-instance-of","text":"Function instanceof takes an object and a type as arguments and returns a boolean if the object is instance of the provided type. Example: let type = Java :: type \"java.math.BigInteger\" instance = Java :: new type [ \"50\" ] in Java :: instanceof instance type","title":"Checking whether an object is instance of"},{"location":"stdlib/java/#casting-an-object-to-another-type","text":"Function case takes an object and a type to which the object should be casted to. Example: let type = Java :: type \"java.math.BigInteger\" instance = Java :: new type [ \"50\" ] cast_to_type = Java :: type \"java.lang.Number\" in Java :: cast instance cast_to_type","title":"Casting an object to another type"},{"location":"stdlib/json/","text":"JSON module is a simple builtin interface for parsing and generating JSON files to and from Yona data types. Usage \u00b6 This module has very simple interface. Just two functions, one to parse a string or a byte sequence, another one taking any Yona value and turning it into a JSON represented as a string. Parsing JSON \u00b6 Function parse takes either a string (character sequence), or a byte sequence (can be obtained by reading a file in a binary mode for example), and produces a Yona value. Example: let { \"1\" = one } = JSON :: parse \"{{ \\\" 1 \\\" : 2, \\\" 3 \\\" : 4}}\" in one This program parses the JSON string and returns a Yona dictionary, which is then pattern matched on and a key of \"1\" is assigned to name one . Thus the result of this expression is 2 . Note that JSON has fewer data types, for example it has no representation of symbols. Regarding numbers, Yona first tries to parse them as integers, if that's not possible, it will parse them as floats. If the parser occurs an invalid input, it throws an exception of type :json_parser_error . This function is implemented as a native builtin in Java, mainly for performance reasons. Generating JSON \u00b6 Function generate is a function of single argument (any Yona value), returning a string containing JSON representation of the passed argument. This function is actually very simple to understand just by reading its source code (it's less than 20 lines of code). Example usage: JSON :: generate { : one = 1 , : two = 2 } As can be seen in the function implementation, symbols are translated into JSON strings, so this function will produce {\"one\": 1, \"two\": 2} .","title":"JSON"},{"location":"stdlib/json/#usage","text":"This module has very simple interface. Just two functions, one to parse a string or a byte sequence, another one taking any Yona value and turning it into a JSON represented as a string.","title":"Usage"},{"location":"stdlib/json/#parsing-json","text":"Function parse takes either a string (character sequence), or a byte sequence (can be obtained by reading a file in a binary mode for example), and produces a Yona value. Example: let { \"1\" = one } = JSON :: parse \"{{ \\\" 1 \\\" : 2, \\\" 3 \\\" : 4}}\" in one This program parses the JSON string and returns a Yona dictionary, which is then pattern matched on and a key of \"1\" is assigned to name one . Thus the result of this expression is 2 . Note that JSON has fewer data types, for example it has no representation of symbols. Regarding numbers, Yona first tries to parse them as integers, if that's not possible, it will parse them as floats. If the parser occurs an invalid input, it throws an exception of type :json_parser_error . This function is implemented as a native builtin in Java, mainly for performance reasons.","title":"Parsing JSON"},{"location":"stdlib/json/#generate","text":"Function generate is a function of single argument (any Yona value), returning a string containing JSON representation of the passed argument. This function is actually very simple to understand just by reading its source code (it's less than 20 lines of code). Example usage: JSON :: generate { : one = 1 , : two = 2 } As can be seen in the function implementation, symbols are translated into JSON strings, so this function will produce {\"one\": 1, \"two\": 2} .","title":"Generating JSON"},{"location":"stdlib/overview/","text":"Following functions and modules are provided as part of the standard library. Functions & Modules \u00b6 Data Structures \u00b6 Modules \u00b6 Seq - contains functions for manipulating sequences Set - contains functions for manipulating sets Dict - contains functions for manipulating dictionaries Tuple - helper functions for analyzing/manipulating tuples STM - Software Transactional Memory Asynchronous Operation \u00b6 Functions \u00b6 async - Executes the lambda asynchronously drop - Execute the callback without waiting on its result never - Function that is never completed sleep - Suspends computation by specified duration timeout - Either the provided value is computed by the specified timeout, or a :timeout exception is raised Type Manipulations \u00b6 Modules \u00b6 Types - contains functions for checking a type of a value Functions \u00b6 str - Converts any value to its string representation int - Converts any number to to int float - Converts any value to float ord - Return byte representation of an ASCII character Control Flow \u00b6 Functions \u00b6 infi - Invoke functions infinite number of times times - Repeat function n times Input/Output \u00b6 Modules \u00b6 IO - standard input/output actions File - contains functions for manipulating files http\\Client - simple HTTP client http\\Server Java - Java interop functions socket\\tcp\\Client - TCP Socket Client socket\\tcp\\Server - TCP Socket Server socket\\tcp\\Connection - Socket Connection handling - reading/writing to sockets terminal\\Colors - Terminal colors terminal\\colors\\Foreground - Terminal colors - foreground terminal\\colors\\Background - Terminal colors - foreground Interoperability \u00b6 Modules \u00b6 java\\Types - Java types conversions Java - Java interoperability interface System - execute external system programs Functions \u00b6 eval - Dynamically evaluates the string as a Yona express Miscellaneous \u00b6 Modules \u00b6 Transducers - contains reducer transformers, used for example by generators context\\Local - utilities for implementing custom context managers, see resource management for details JSON - JSON parser and generator functions Regexp - Regular Expressions Stopwatch - Simple benchmarking utilities Exception - Exception handling related utilities Random - Random number generation Scheduler - Simple task scheduling Functions \u00b6 identity - Returns the value provided to it as an argument, without any modification Time & Date \u00b6 Modules \u00b6 Time - Time related functions","title":"Overview"},{"location":"stdlib/overview/#functions-modules","text":"","title":"Functions &amp; Modules"},{"location":"stdlib/overview/#data-structures","text":"","title":"Data Structures"},{"location":"stdlib/overview/#modules","text":"Seq - contains functions for manipulating sequences Set - contains functions for manipulating sets Dict - contains functions for manipulating dictionaries Tuple - helper functions for analyzing/manipulating tuples STM - Software Transactional Memory","title":"Modules"},{"location":"stdlib/overview/#asynchronous-operation","text":"","title":"Asynchronous Operation"},{"location":"stdlib/overview/#functions","text":"async - Executes the lambda asynchronously drop - Execute the callback without waiting on its result never - Function that is never completed sleep - Suspends computation by specified duration timeout - Either the provided value is computed by the specified timeout, or a :timeout exception is raised","title":"Functions"},{"location":"stdlib/overview/#type-manipulations","text":"","title":"Type Manipulations"},{"location":"stdlib/overview/#modules_1","text":"Types - contains functions for checking a type of a value","title":"Modules"},{"location":"stdlib/overview/#functions_1","text":"str - Converts any value to its string representation int - Converts any number to to int float - Converts any value to float ord - Return byte representation of an ASCII character","title":"Functions"},{"location":"stdlib/overview/#control-flow","text":"","title":"Control Flow"},{"location":"stdlib/overview/#functions_2","text":"infi - Invoke functions infinite number of times times - Repeat function n times","title":"Functions"},{"location":"stdlib/overview/#inputoutput","text":"","title":"Input/Output"},{"location":"stdlib/overview/#modules_2","text":"IO - standard input/output actions File - contains functions for manipulating files http\\Client - simple HTTP client http\\Server Java - Java interop functions socket\\tcp\\Client - TCP Socket Client socket\\tcp\\Server - TCP Socket Server socket\\tcp\\Connection - Socket Connection handling - reading/writing to sockets terminal\\Colors - Terminal colors terminal\\colors\\Foreground - Terminal colors - foreground terminal\\colors\\Background - Terminal colors - foreground","title":"Modules"},{"location":"stdlib/overview/#interoperability","text":"","title":"Interoperability"},{"location":"stdlib/overview/#modules_3","text":"java\\Types - Java types conversions Java - Java interoperability interface System - execute external system programs","title":"Modules"},{"location":"stdlib/overview/#functions_3","text":"eval - Dynamically evaluates the string as a Yona express","title":"Functions"},{"location":"stdlib/overview/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"stdlib/overview/#modules_4","text":"Transducers - contains reducer transformers, used for example by generators context\\Local - utilities for implementing custom context managers, see resource management for details JSON - JSON parser and generator functions Regexp - Regular Expressions Stopwatch - Simple benchmarking utilities Exception - Exception handling related utilities Random - Random number generation Scheduler - Simple task scheduling","title":"Modules"},{"location":"stdlib/overview/#functions_4","text":"identity - Returns the value provided to it as an argument, without any modification","title":"Functions"},{"location":"stdlib/overview/#time-date","text":"","title":"Time &amp; Date"},{"location":"stdlib/overview/#modules_5","text":"Time - Time related functions","title":"Modules"},{"location":"stdlib/random/","text":"Random number generation. Not cryptographically secure. Usage \u00b6 Use functions for different types of random values. Random integer from a range \u00b6 Function integer_lt takes an integer as an argument and generates a random number from 0(inclusive) to this upper limit(exclusive). Random :: integer_lt 5 # 0 , 1 , 2 , 3 or 4","title":"Random"},{"location":"stdlib/random/#usage","text":"Use functions for different types of random values.","title":"Usage"},{"location":"stdlib/random/#random-integer-from-a-range","text":"Function integer_lt takes an integer as an argument and generates a random number from 0(inclusive) to this upper limit(exclusive). Random :: integer_lt 5 # 0 , 1 , 2 , 3 or 4","title":"Random integer from a range"},{"location":"stdlib/regexp/","text":"This module provides functions for compiling, executing and replacing regular expressions. Note that Yona supports a subset of ECMAscript regular expressions, with the exception of back-references and arbitrary look-behind assertions. Usage \u00b6 Module Regexp provides functions for compiling a regular expression from a string: compile , for executing them: exec , which finds occurrences of provided regular expression in the input string and replace that replaces occrrence of the regular expression match for a replacement string. Compiling regular expressions \u00b6 Before using other functions, regular expression must be first compiled. Yona provides function compile that takes a string describing the regular expression and a set of options: - global : With this flag the search looks for all matches, without it \u2013 only the first match is returned. - multiline : Multiline mode. - ignore_case : With this flag the search is case-insensitive: no difference between A and a . - sticky : \"Sticky\" mode: searching at the exact position in the text. - unicode : Enables full unicode support. The flag enables correct processing of surrogate pairs. - dot_all : Enables \"dotall\" mode, that allows a dot . to match newline character \\n . Example: Regexp :: compile \"(a|(b))c\" { : ignore_case } Matching strings with regular expressions \u00b6 Function exec \"executes\" a regular expression on the provided input, returning all matches as a sequence of matched strings, if none found, returning an empty sequence. It expects arguments in this order: - input string - compiled regular expression Example: Regexp :: compile \"(a|(b))c\" { : ignore_case } |> Regexp :: exec \"xacy\" will return [\"ac\", \"a\"] Replacing strings with regular expressions \u00b6 Function replace replaces occurrences matching the provided regular expression on the input with the provided replacement. It expects arguments in this order: - input string - replacement string - compiled regular expression Example: Regexp :: compile \"we\" { : ignore_case , : global } |> Regexp :: replace \"We will, we will\" \"she\" which will produce \"she will, she will\" Additionally, the replacement string may contain these special combinations of strings: - $$ which are replaced with $ - $& which are replaced with the whole match","title":"Regexp"},{"location":"stdlib/regexp/#usage","text":"Module Regexp provides functions for compiling a regular expression from a string: compile , for executing them: exec , which finds occurrences of provided regular expression in the input string and replace that replaces occrrence of the regular expression match for a replacement string.","title":"Usage"},{"location":"stdlib/regexp/#compiling-regular-expressions","text":"Before using other functions, regular expression must be first compiled. Yona provides function compile that takes a string describing the regular expression and a set of options: - global : With this flag the search looks for all matches, without it \u2013 only the first match is returned. - multiline : Multiline mode. - ignore_case : With this flag the search is case-insensitive: no difference between A and a . - sticky : \"Sticky\" mode: searching at the exact position in the text. - unicode : Enables full unicode support. The flag enables correct processing of surrogate pairs. - dot_all : Enables \"dotall\" mode, that allows a dot . to match newline character \\n . Example: Regexp :: compile \"(a|(b))c\" { : ignore_case }","title":"Compiling regular expressions"},{"location":"stdlib/regexp/#matching-strings-with-regular-expressions","text":"Function exec \"executes\" a regular expression on the provided input, returning all matches as a sequence of matched strings, if none found, returning an empty sequence. It expects arguments in this order: - input string - compiled regular expression Example: Regexp :: compile \"(a|(b))c\" { : ignore_case } |> Regexp :: exec \"xacy\" will return [\"ac\", \"a\"]","title":"Matching strings with regular expressions"},{"location":"stdlib/regexp/#replacing-strings-with-regular-expressions","text":"Function replace replaces occurrences matching the provided regular expression on the input with the provided replacement. It expects arguments in this order: - input string - replacement string - compiled regular expression Example: Regexp :: compile \"we\" { : ignore_case , : global } |> Regexp :: replace \"We will, we will\" \"she\" which will produce \"she will, she will\" Additionally, the replacement string may contain these special combinations of strings: - $$ which are replaced with $ - $& which are replaced with the whole match","title":"Replacing strings with regular expressions"},{"location":"stdlib/scheduler/","text":"Simple scheduling of tasks. Usage \u00b6 Use this module to schedule task execution. Scheduling a repeating task \u00b6 Function run accepts two argument: how_often a tuple representing how often the task should be repeated what a 0-argument function to be run in the provided period Depending on the how_often , the first execution is delayed until the next occurrence of this period. In other words, the first invocation of (:every, :minute) will happen in the next exact minute, if it's 13:32:40 now, then the first invocation is 13:33:00 . If it's (:every, :day) , then the first run will be scheduled at 00:00:00 the next day. Specification of how_often options \u00b6 Frequency of the execution is specified as a tuple like (:every, time_unit) , where time_unit is one of: :second :minute :hour :day :week Examples: Scheduler :: run ( : every , : minute ) ( \\-> IO :: println \"hello\" ) # print hello every minute at 0 seconds","title":"Scheduler"},{"location":"stdlib/scheduler/#usage","text":"Use this module to schedule task execution.","title":"Usage"},{"location":"stdlib/scheduler/#scheduling-a-repeating-task","text":"Function run accepts two argument: how_often a tuple representing how often the task should be repeated what a 0-argument function to be run in the provided period Depending on the how_often , the first execution is delayed until the next occurrence of this period. In other words, the first invocation of (:every, :minute) will happen in the next exact minute, if it's 13:32:40 now, then the first invocation is 13:33:00 . If it's (:every, :day) , then the first run will be scheduled at 00:00:00 the next day.","title":"Scheduling a repeating task"},{"location":"stdlib/scheduler/#specification-of-how_often-options","text":"Frequency of the execution is specified as a tuple like (:every, time_unit) , where time_unit is one of: :second :minute :hour :day :week Examples: Scheduler :: run ( : every , : minute ) ( \\-> IO :: println \"hello\" ) # print hello every minute at 0 seconds","title":"Specification of how_often options"},{"location":"stdlib/seq/","text":"This module provides functions for manipulating Sequences. Sequences are bi-directional, immutable data structures with constant time random element lookup. Strings in Yona are specially optimized sequences of UTF-8 characters. Usage \u00b6 There is a special syntax to create an empty sequence: [] or \"\" . Sequences support special operators for adding elements or joining with other sequences. Folding a sequence \u00b6 Folding a sequence is a process of iterating over its values while producing one result value. An example of a folding function could be a sum function, that iterates over all elements and adds them up, producing a single result. Sequences can be folded from both directions - left or right. Module Seq contains functions foldl and foldr for folding from the left or right side respectively. Functions foldl and foldr take 3 arguments: * 2-argument lambda (accumulator, element) returning a new value of an accumulator * initial value of the accumulator * sequence to fold This example shows how to sum up a sequence: Seq :: foldl ( \\ acc val -> acc + val ) 0 [ 1 , 2 , 3 ] Reducing a sequence \u00b6 Reducing a sequence means applying a transducer onto a sequence. Transducers are a generic, high-level method for implementing operations over a data structure. Function reduce takes 2 arguments: * transducer * sequence to reduce Example with a filter transducer: Seq :: reducel ( Transducers :: filter \\ val -> val < 0 ( 0 , \\ acc val -> acc + val , \\ acc -> acc * 2 )) [ - 2 , - 1 , 0 , 1 , 2 ] This example will produce -6 , as it sums up all negative numbers in the sequence. Obtaining a length of a sequence \u00b6 Function len returns a length of a sequence: length = Seq :: len [ 1 , 2 , 3 ] Splitting a sequence at an index \u00b6 Function splitAt splits the sequence at a given index into a tuple of two sequences: Seq :: split_at 2 [ 1 , 2 , 3 , 4 , 5 ] will yield ([1, 2], [3, 4, 5]) Checking whether a sequence is a string \u00b6 Function is_string checks whether a sequence is a string. It can be useful in guard expressions for example. Seq :: is_string \"hello\" will result in a true . Looking up an element by an index \u00b6 Function lookup takes an index and a sequence and returns an element on that index. It throws :badarg exception if the index is not found. Seq :: lookup 2 [ 1 , 2 , 3 ] Taking first n elements \u00b6 Function takes takes first n elements. It throws :badarg exception if the n is greater or equal than the length of the sequence. Seq :: take 2 [ 1 , 2 , 3 ] # returns [ 1 , 2 ] Dropping first n elements \u00b6 Function drop drops first n elements. It throws :badarg exception if the n is greater or equal than the length of the sequence. Seq :: drops 2 [ 1 , 2 , 3 ] # returns [ 3 ] Zipping two sequences into one \u00b6 Function zip takes two sequences and produces one with tuples, one from each sequence. Example: Seq :: zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] Will create a new sequence [(1, 4), (2, 5), (3, 6)] . Encoding / Decoding strings \u00b6 Functions encode and decode convert Strings (UTF-8 character sequences) to and from Sequence of bytes. Seq :: encode \"hello\" |> Seq :: decode # returns \"hello\" Trimming whitespace \u00b6 Returns a string whose value is this string, with all leading and trailing space removed, where space is defined as any character whose codepoint is less than or equal to U+0020 (the space character). Seq :: trim \" hello \" # returns \"hello\" Flattening a sequence of sequences \u00b6 Function flatten will flatten a nested sequence containing other sequences into a flat sequence. Seq :: flatten [[ 1 , 2 ], [ 3 , [ 4 , 5 , [ 6 , 7 ]]]] Will produce a new sequence [1, 2, 3, 4, 5, 6, 7] . Joining a sequence of strings with a separator \u00b6 Function join takes a separator string and a sequence of strings to be join with them. Seq :: join \" \\n \" [ \"line 1\" , \"line2\" , \"line 3\" ] Will produce three lines: line 1 line 2 line 3","title":"Seq"},{"location":"stdlib/seq/#usage","text":"There is a special syntax to create an empty sequence: [] or \"\" . Sequences support special operators for adding elements or joining with other sequences.","title":"Usage"},{"location":"stdlib/seq/#folding-a-sequence","text":"Folding a sequence is a process of iterating over its values while producing one result value. An example of a folding function could be a sum function, that iterates over all elements and adds them up, producing a single result. Sequences can be folded from both directions - left or right. Module Seq contains functions foldl and foldr for folding from the left or right side respectively. Functions foldl and foldr take 3 arguments: * 2-argument lambda (accumulator, element) returning a new value of an accumulator * initial value of the accumulator * sequence to fold This example shows how to sum up a sequence: Seq :: foldl ( \\ acc val -> acc + val ) 0 [ 1 , 2 , 3 ]","title":"Folding a sequence"},{"location":"stdlib/seq/#reducing-a-sequence","text":"Reducing a sequence means applying a transducer onto a sequence. Transducers are a generic, high-level method for implementing operations over a data structure. Function reduce takes 2 arguments: * transducer * sequence to reduce Example with a filter transducer: Seq :: reducel ( Transducers :: filter \\ val -> val < 0 ( 0 , \\ acc val -> acc + val , \\ acc -> acc * 2 )) [ - 2 , - 1 , 0 , 1 , 2 ] This example will produce -6 , as it sums up all negative numbers in the sequence.","title":"Reducing a sequence"},{"location":"stdlib/seq/#obtaining-a-length-of-a-sequence","text":"Function len returns a length of a sequence: length = Seq :: len [ 1 , 2 , 3 ]","title":"Obtaining a length of a sequence"},{"location":"stdlib/seq/#splitting-a-sequence-at-an-index","text":"Function splitAt splits the sequence at a given index into a tuple of two sequences: Seq :: split_at 2 [ 1 , 2 , 3 , 4 , 5 ] will yield ([1, 2], [3, 4, 5])","title":"Splitting a sequence at an index"},{"location":"stdlib/seq/#checking-whether-a-sequence-is-a-string","text":"Function is_string checks whether a sequence is a string. It can be useful in guard expressions for example. Seq :: is_string \"hello\" will result in a true .","title":"Checking whether a sequence is a string"},{"location":"stdlib/seq/#looking-up-an-element-by-an-index","text":"Function lookup takes an index and a sequence and returns an element on that index. It throws :badarg exception if the index is not found. Seq :: lookup 2 [ 1 , 2 , 3 ]","title":"Looking up an element by an index"},{"location":"stdlib/seq/#taking-first-n-elements","text":"Function takes takes first n elements. It throws :badarg exception if the n is greater or equal than the length of the sequence. Seq :: take 2 [ 1 , 2 , 3 ] # returns [ 1 , 2 ]","title":"Taking first n elements"},{"location":"stdlib/seq/#dropping-first-n-elements","text":"Function drop drops first n elements. It throws :badarg exception if the n is greater or equal than the length of the sequence. Seq :: drops 2 [ 1 , 2 , 3 ] # returns [ 3 ]","title":"Dropping first n elements"},{"location":"stdlib/seq/#zipping-two-sequences-into-one","text":"Function zip takes two sequences and produces one with tuples, one from each sequence. Example: Seq :: zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] Will create a new sequence [(1, 4), (2, 5), (3, 6)] .","title":"Zipping two sequences into one"},{"location":"stdlib/seq/#encoding-decoding-strings","text":"Functions encode and decode convert Strings (UTF-8 character sequences) to and from Sequence of bytes. Seq :: encode \"hello\" |> Seq :: decode # returns \"hello\"","title":"Encoding / Decoding strings"},{"location":"stdlib/seq/#trimming-whitespace","text":"Returns a string whose value is this string, with all leading and trailing space removed, where space is defined as any character whose codepoint is less than or equal to U+0020 (the space character). Seq :: trim \" hello \" # returns \"hello\"","title":"Trimming whitespace"},{"location":"stdlib/seq/#flattening-a-sequence-of-sequences","text":"Function flatten will flatten a nested sequence containing other sequences into a flat sequence. Seq :: flatten [[ 1 , 2 ], [ 3 , [ 4 , 5 , [ 6 , 7 ]]]] Will produce a new sequence [1, 2, 3, 4, 5, 6, 7] .","title":"Flattening a sequence of sequences"},{"location":"stdlib/seq/#join","text":"Function join takes a separator string and a sequence of strings to be join with them. Seq :: join \" \\n \" [ \"line 1\" , \"line2\" , \"line 3\" ] Will produce three lines: line 1 line 2 line 3","title":"Joining a sequence of strings with a separator"},{"location":"stdlib/set/","text":"This module provides functions for manipulating Sets. Sets are immutable data structure containing unique elements. Usage \u00b6 There is function Set::empty to create a new empty set. Sets support special operators for adding elements or operations typical for sets, such as unions or intersections etc. Folding a set \u00b6 Folding a set is a process of iterating over its values while producing one result value. An example of a folding function could be a sum function, that iterates over all elements and adds them up, producing a single result. Functions foldl take 3 arguments: * 2-argument lambda (accumulator, element) returning a new value of an accumulator * initial value of the accumulator * set to fold This example shows how to sum up a set: Set :: fold ( \\ acc val -> acc + val ) 0 { 1 , 2 , 3 } Reducing a set \u00b6 Reducing a set means applying a transducer onto a set. Transducers are a generic, high-level method for implementing operations over a data structure. Function reduce takes 2 arguments: * transducer * set to reduce Example with a filter transducer: Set :: reduce ( Transducers :: filter \\ val -> val < 0 ( 0 , \\ state val -> state + val , \\ state -> state * 2 )) {-2,-1,0,1,2} This example will produce -6 , as it sums up all negative numbers in the set. Obtaining a length of a set \u00b6 Function len returns a length of a set: length = Set :: len { 1 , 2 , 3 } Turning a set to a sequence \u00b6 Function to_seq constructs a sequence containing elemtents of the given set. Elements in this sequence are in no particular order. Example: Set :: to_seq { 1 , 2 , 3 } Will return [1, 2, 3] .","title":"Set"},{"location":"stdlib/set/#usage","text":"There is function Set::empty to create a new empty set. Sets support special operators for adding elements or operations typical for sets, such as unions or intersections etc.","title":"Usage"},{"location":"stdlib/set/#folding-a-set","text":"Folding a set is a process of iterating over its values while producing one result value. An example of a folding function could be a sum function, that iterates over all elements and adds them up, producing a single result. Functions foldl take 3 arguments: * 2-argument lambda (accumulator, element) returning a new value of an accumulator * initial value of the accumulator * set to fold This example shows how to sum up a set: Set :: fold ( \\ acc val -> acc + val ) 0 { 1 , 2 , 3 }","title":"Folding a set"},{"location":"stdlib/set/#reducing-a-set","text":"Reducing a set means applying a transducer onto a set. Transducers are a generic, high-level method for implementing operations over a data structure. Function reduce takes 2 arguments: * transducer * set to reduce Example with a filter transducer: Set :: reduce ( Transducers :: filter \\ val -> val < 0 ( 0 , \\ state val -> state + val , \\ state -> state * 2 )) {-2,-1,0,1,2} This example will produce -6 , as it sums up all negative numbers in the set.","title":"Reducing a set"},{"location":"stdlib/set/#obtaining-a-length-of-a-set","text":"Function len returns a length of a set: length = Set :: len { 1 , 2 , 3 }","title":"Obtaining a length of a set"},{"location":"stdlib/set/#turning-a-set-to-a-sequence","text":"Function to_seq constructs a sequence containing elemtents of the given set. Elements in this sequence are in no particular order. Example: Set :: to_seq { 1 , 2 , 3 } Will return [1, 2, 3] .","title":"Turning a set to a sequence"},{"location":"stdlib/stm/","text":"Module STM provides access to a built-in Software Transactional Memory data structure, which can be thought of as a mutable map, safe from concurrent access. Usage \u00b6 There may be multiple instances of STM created in Yona, and they live completely independently to each other. Any error raised by functions in this module raise an exception of type :stm . Any expression inside the body of a context manager will have implicit access to the transaction from its scope. Instantiating a new STM \u00b6 In order to use an STM for read/write operations, one must first create the STM itself. Reference to the STM instance will be used by all other functions. STM itself is of a special type stm . Example: stm = STM :: new Creating a var - key for some value in the STM \u00b6 STM uses concepts of vars, which are references to the STM, and they are actually their own special type in Yona. Creating a new var: var = STM :: var stm initial_value Creating a new var requires the STM instance and an initial value this var holds. Starting a read-only transaction \u00b6 Function read_tx creates a read-only transaction wrapped in a context manager . It takes a reference to the STM system and returns the context manager. Access the STM in a transaction: with STM :: read_tx stm STM :: run ( \\-> check_balance ) end Starting a read-write transaction \u00b6 Function write_tx creates a read-write transaction wrapped in a context manager . It takes a reference to the STM system and returns the context manager. Access the STM in a transaction: with STM :: write_tx stm STM :: run ( \\-> withdraw ) end Note that passing a zero argument lambda requires it to be wrapped in another lambda, this is to prevent its eager evaluation. Reading a value of a var \u00b6 A var may be read either inside or outside of a transaction. Reading a var outside of a transaction, aka a dirty read, may provide a value that has been modified by another running transaction and not yet committed. Funciton read expects one argument, the var and returns a value this var contains. Example: value = STM :: read var Writing to a var \u00b6 Function var must be called within a transaction. It expects var and the new value to be written. This function returns a () . Example: STM :: write var new_value Protecting a var from a concurrent write in another transaction \u00b6 Function protect ensures that a var cannot be overriden from another transaction. If such change did occur, the current transaction would fail. This function expects a var and returns a () . Example: STM :: protect var Complete example \u00b6 The following example shows a simple program for withdrawing money from an account. 10 currency is withdrawn 100 times: let stm = STM :: new balance = STM :: var stm 1000 f max_iterations = 100 run = \\ i -> case i of x | x >= max_iterations -> STM :: read balance x -> do with STM :: write_tx stm let old_balance = STM :: read balance in STM :: write balance ( old_balance - 10 f ) end run ( i + 1 ) end end in run 0","title":"STM"},{"location":"stdlib/stm/#usage","text":"There may be multiple instances of STM created in Yona, and they live completely independently to each other. Any error raised by functions in this module raise an exception of type :stm . Any expression inside the body of a context manager will have implicit access to the transaction from its scope.","title":"Usage"},{"location":"stdlib/stm/#instantiating-a-new-stm","text":"In order to use an STM for read/write operations, one must first create the STM itself. Reference to the STM instance will be used by all other functions. STM itself is of a special type stm . Example: stm = STM :: new","title":"Instantiating a new STM"},{"location":"stdlib/stm/#creating-a-var-key-for-some-value-in-the-stm","text":"STM uses concepts of vars, which are references to the STM, and they are actually their own special type in Yona. Creating a new var: var = STM :: var stm initial_value Creating a new var requires the STM instance and an initial value this var holds.","title":"Creating a var - key for some value in the STM"},{"location":"stdlib/stm/#starting-a-read-only-transaction","text":"Function read_tx creates a read-only transaction wrapped in a context manager . It takes a reference to the STM system and returns the context manager. Access the STM in a transaction: with STM :: read_tx stm STM :: run ( \\-> check_balance ) end","title":"Starting a read-only transaction"},{"location":"stdlib/stm/#starting-a-read-write-transaction","text":"Function write_tx creates a read-write transaction wrapped in a context manager . It takes a reference to the STM system and returns the context manager. Access the STM in a transaction: with STM :: write_tx stm STM :: run ( \\-> withdraw ) end Note that passing a zero argument lambda requires it to be wrapped in another lambda, this is to prevent its eager evaluation.","title":"Starting a read-write transaction"},{"location":"stdlib/stm/#reading-a-value-of-a-var","text":"A var may be read either inside or outside of a transaction. Reading a var outside of a transaction, aka a dirty read, may provide a value that has been modified by another running transaction and not yet committed. Funciton read expects one argument, the var and returns a value this var contains. Example: value = STM :: read var","title":"Reading a value of a var"},{"location":"stdlib/stm/#writing-to-a-var","text":"Function var must be called within a transaction. It expects var and the new value to be written. This function returns a () . Example: STM :: write var new_value","title":"Writing to a var"},{"location":"stdlib/stm/#protecting-a-var-from-a-concurrent-write-in-another-transaction","text":"Function protect ensures that a var cannot be overriden from another transaction. If such change did occur, the current transaction would fail. This function expects a var and returns a () . Example: STM :: protect var","title":"Protecting a var from a concurrent write in another transaction"},{"location":"stdlib/stm/#complete-example","text":"The following example shows a simple program for withdrawing money from an account. 10 currency is withdrawn 100 times: let stm = STM :: new balance = STM :: var stm 1000 f max_iterations = 100 run = \\ i -> case i of x | x >= max_iterations -> STM :: read balance x -> do with STM :: write_tx stm let old_balance = STM :: read balance in STM :: write balance ( old_balance - 10 f ) end run ( i + 1 ) end end in run 0","title":"Complete example"},{"location":"stdlib/stopwatch/","text":"This module provides some basic stopwatch or timer ability. Usage \u00b6 Function nanos will accept a function of zero arguments and return a tuple, where the first element represent time spent executing this function and the second element is the original result of the function passed. Example: Stopwatch :: nanos ( \\-> sleep 5 )","title":"Stopwatch"},{"location":"stdlib/stopwatch/#usage","text":"Function nanos will accept a function of zero arguments and return a tuple, where the first element represent time spent executing this function and the second element is the original result of the function passed. Example: Stopwatch :: nanos ( \\-> sleep 5 )","title":"Usage"},{"location":"stdlib/system/","text":"This module provides functions for interacting with the system environment, such as external processes, or environment variables. Usage \u00b6 Accessing program arguments \u00b6 Function args allows the program to access the process arguments, so for example running a script such as: yona ./script.yona -h would result in: [ \"-h\" ] = System :: args Getting PID \u00b6 Function pid returns the PID of the running process, as an integer number. pid = System :: pid Getting environment variable \u00b6 Function get_env returns an environment variable as a string or a () if such environment variable is not present. yona_path = System :: get_env \"YONA_PATH\" Running an external process \u00b6 Function run is used to run an external process. It takes a sequence of strings, of which the first is the process to run and following strings are arguments for that process. The process will be executed in a non-blocking matter, and the result of this function is a triple of (exit_code, std_out, std_err) , where * exit_code is the exit code of the executed process * std_out is captured standard output of the executed process * std_err is captured standard error output of the executed process Example: System :: run [ \"echo\" , \"hello world\" ] Running a pipeline of external process \u00b6 Function pipeline is used to run a pipeline of external processes. The process will be executed in a non-blocking matter, and the result of this function is a triple of (exit_code, std_out, std_err) , where * exit_code is the exit code of the last executed process * std_out is captured standard output of the last executed process * std_err is captured standard error output of the last executed process Processes are linked by their standard input and output streams. Example which will reverse a string and produce \"olleh\" as a result: System :: pipeline [ [ \"echo\" , \"hello\" ], [ \"rev\" ] ] Locating the language home \u00b6 Function language_home returns a string representing an absolute path to the home directory of the language installation within the GraalVM. For example: System :: language_home |> println could print something like: /Library/Java/JavaVirtualMachines/graalvm-ee-java11-20.1.0/Contents/Home/languages/yona","title":"System"},{"location":"stdlib/system/#usage","text":"","title":"Usage"},{"location":"stdlib/system/#accessing-program-arguments","text":"Function args allows the program to access the process arguments, so for example running a script such as: yona ./script.yona -h would result in: [ \"-h\" ] = System :: args","title":"Accessing program arguments"},{"location":"stdlib/system/#getting-pid","text":"Function pid returns the PID of the running process, as an integer number. pid = System :: pid","title":"Getting PID"},{"location":"stdlib/system/#getting-environment-variable","text":"Function get_env returns an environment variable as a string or a () if such environment variable is not present. yona_path = System :: get_env \"YONA_PATH\"","title":"Getting environment variable"},{"location":"stdlib/system/#running-an-external-process","text":"Function run is used to run an external process. It takes a sequence of strings, of which the first is the process to run and following strings are arguments for that process. The process will be executed in a non-blocking matter, and the result of this function is a triple of (exit_code, std_out, std_err) , where * exit_code is the exit code of the executed process * std_out is captured standard output of the executed process * std_err is captured standard error output of the executed process Example: System :: run [ \"echo\" , \"hello world\" ]","title":"Running an external process"},{"location":"stdlib/system/#running-a-pipeline-of-external-process","text":"Function pipeline is used to run a pipeline of external processes. The process will be executed in a non-blocking matter, and the result of this function is a triple of (exit_code, std_out, std_err) , where * exit_code is the exit code of the last executed process * std_out is captured standard output of the last executed process * std_err is captured standard error output of the last executed process Processes are linked by their standard input and output streams. Example which will reverse a string and produce \"olleh\" as a result: System :: pipeline [ [ \"echo\" , \"hello\" ], [ \"rev\" ] ]","title":"Running a pipeline of external process"},{"location":"stdlib/system/#locating-the-language-home","text":"Function language_home returns a string representing an absolute path to the home directory of the language installation within the GraalVM. For example: System :: language_home |> println could print something like: /Library/Java/JavaVirtualMachines/graalvm-ee-java11-20.1.0/Contents/Home/languages/yona","title":"Locating the language home"},{"location":"stdlib/time/","text":"This module provides functions for working with time. Obtaining current time since epoch, in seconds \u00b6 Function unix returns current time since the epoch in seconds. Example: Time::unix |> IO::println","title":"Time"},{"location":"stdlib/time/#obtaining-current-time-since-epoch-in-seconds","text":"Function unix returns current time since the epoch in seconds. Example: Time::unix |> IO::println","title":"Obtaining current time since epoch, in seconds"},{"location":"stdlib/transducers/","text":"Transducers are composable transformations of reducing functions. They provide a way to implement high-order operations such as map , filter , take or drop in a way that they are independent of the collection they operate on. This way, these operations are defined only once, for all collections in Yona, specifically for Seq , Set and Dict and in fact, they can be used for custom user-built data collections, provided that it exposes a reduce function. Transducer constructor is a function that takes a transducer as an argument and returns a new transducer. Using a transducer \u00b6 Transducer needs to be used in a combination with reduce function, best seen in an example, a sequence can be filtered like this: let transducer = Transducers :: filter \\ val -> val < 0 ( 0 , \\ acc val -> acc + val , \\ acc -> acc * 2 ) in Seq :: reducer [ - 2 , - 1 , 0 , 1 , 2 ] transducer What this code does, is that it calls function Seq::reducer with two arguments: sequence to reduce transducer And the transducer is constructed by function Transducers::filter , which takes two arguments: predicate - function to filter elements added to the resulting collection transducer The second argument here is another transducer actually. This is how transducers are composed. Transducer can either be created by using a predefined one in the Transducers module, or created manually as a tripple, as described in the next section. Implementing a transducer \u00b6 Transducer in Yona is a tripple, with following elements: initial state - is the initial state of the accumulator of the step function step function - is a function of two arguments - accumulator and an element, returning a new state of the accumulator complete function - is a function of one argument - the final state of the accumulator, returning the final value of the reduce function Example: filter transducer \u00b6 # pred : function of one argument ( element ) returning boolean value # init : initial state # step : function of two arguments ( accumulator , element ) returning new value of the accumulator # complete : function of one argument ( final state of accumulator ) returning final return value filter pred ( init , step , complete ) = let new_step = \\ acc val -> if pred val then step acc val else acc in ( init , new_step , complete ) Source code for all transducers available in Yona is available here . Note that transducers are actually used in generators as well, they are just a syntax sugar for them for the built-in collections.","title":"Transducers"},{"location":"stdlib/transducers/#using-a-transducer","text":"Transducer needs to be used in a combination with reduce function, best seen in an example, a sequence can be filtered like this: let transducer = Transducers :: filter \\ val -> val < 0 ( 0 , \\ acc val -> acc + val , \\ acc -> acc * 2 ) in Seq :: reducer [ - 2 , - 1 , 0 , 1 , 2 ] transducer What this code does, is that it calls function Seq::reducer with two arguments: sequence to reduce transducer And the transducer is constructed by function Transducers::filter , which takes two arguments: predicate - function to filter elements added to the resulting collection transducer The second argument here is another transducer actually. This is how transducers are composed. Transducer can either be created by using a predefined one in the Transducers module, or created manually as a tripple, as described in the next section.","title":"Using a transducer"},{"location":"stdlib/transducers/#implementing-a-transducer","text":"Transducer in Yona is a tripple, with following elements: initial state - is the initial state of the accumulator of the step function step function - is a function of two arguments - accumulator and an element, returning a new state of the accumulator complete function - is a function of one argument - the final state of the accumulator, returning the final value of the reduce function","title":"Implementing a transducer"},{"location":"stdlib/transducers/#example-filter-transducer","text":"# pred : function of one argument ( element ) returning boolean value # init : initial state # step : function of two arguments ( accumulator , element ) returning new value of the accumulator # complete : function of one argument ( final state of accumulator ) returning final return value filter pred ( init , step , complete ) = let new_step = \\ acc val -> if pred val then step acc val else acc in ( init , new_step , complete ) Source code for all transducers available in Yona is available here . Note that transducers are actually used in generators as well, they are just a syntax sugar for them for the built-in collections.","title":"Example: filter transducer"},{"location":"stdlib/tuple/","text":"This is a simple module providing functions for manipulating tuples. Usage \u00b6 Currently this module provides a single function, for converting a tuple into a sequence. Converting a tuple into a sequence \u00b6 Function to_seq takes a tuple and turns into a sequence. Example: let seq = ( : one , : two ) in seq Will produce [:one, :two] .","title":"Tuple"},{"location":"stdlib/tuple/#usage","text":"Currently this module provides a single function, for converting a tuple into a sequence.","title":"Usage"},{"location":"stdlib/tuple/#converting-a-tuple-into-a-sequence","text":"Function to_seq takes a tuple and turns into a sequence. Example: let seq = ( : one , : two ) in seq Will produce [:one, :two] .","title":"Converting a tuple into a sequence"},{"location":"stdlib/types/","text":"This module provides functions for checking the type of a particular value, which is particularly useful in guard expressions . Usage \u00b6 All functions in this module take one argument and they return a boolean, depending whether the value is of the given type or not. List of available functions: * is_boolean * is_byte * is_integer * is_float * is_char * is_function * is_tuple * is_module * is_seq * is_dict * is_set * is_native * is_symbol * is_stm * is_var","title":"Types"},{"location":"stdlib/types/#usage","text":"All functions in this module take one argument and they return a boolean, depending whether the value is of the given type or not. List of available functions: * is_boolean * is_byte * is_integer * is_float * is_char * is_function * is_tuple * is_module * is_seq * is_dict * is_set * is_native * is_symbol * is_stm * is_var","title":"Usage"},{"location":"stdlib/context/local/","text":"This module provides functions for implementing user-level context managers . It provides necessary functions that allow reading the local context dictionary as well as convenience functions for constructing and deconstructing the context manager tuples. Creating a new custom context manager \u00b6 Function new takes four arguments and builds a new context manager tuple: name is the default name of the alias, used as a key in the local context dictionary. wrapper wrapper: 2-arg function - the context manager tuple and a callback that is called from within this wrapper function and of which result is returned as a result of this wrapper. The wrapper can perfrom initialization and finalization of resources around calling the callback. data is the actual data, such as transaction object, file object or whatever other resource data to be managed by the context manager. This example builds a simple test context manager that multiplies its data within its wrapper function, provided that 4 is its initial data . context\\ Local :: new \"test_context\" ( \\ ctx_mgr cb -> ( cb ) * 2 ) 4 Looking up a value in the local context dictionary \u00b6 Function lookup returns a value in the local context dictionary by the key (string), or () if not found. Checking whether a key is present in the local context dictionary \u00b6 Function contains returns true if the key (string) is present in the local context dictionary, or not. Getting the default name of the context manager \u00b6 Obtaining the name from the context manager tuple can be done using function get_name . It takes context manager tuple as its only argument and returns the name . Getting the initialization function of the context manager \u00b6 Obtaining the wrapper from the context manager tuple can be done using function get_wrapper . It takes context manager tuple as its only argument and returns the wrapper function. Getting the data of the managed resource of the context manager \u00b6 Obtaining the data from the context manager tuple can be done using function get_data . It takes context manager tuple as its only argument and returns the data function. Using this context manager in a simple test program coul look like: with context \\ Local :: new \"test_context\" ( \\ ctx_mgr cb -> ( cb ) * 2 ) 4 as test_context # name : \"test_context\" # wrapper : \\ cm -> ( context \\ Local :: get_data cm ) * 2 # data : 4 let data = context \\ Local :: get_data test_context in data * 2 end","title":"context\\Local"},{"location":"stdlib/context/local/#creating-a-new-custom-context-manager","text":"Function new takes four arguments and builds a new context manager tuple: name is the default name of the alias, used as a key in the local context dictionary. wrapper wrapper: 2-arg function - the context manager tuple and a callback that is called from within this wrapper function and of which result is returned as a result of this wrapper. The wrapper can perfrom initialization and finalization of resources around calling the callback. data is the actual data, such as transaction object, file object or whatever other resource data to be managed by the context manager. This example builds a simple test context manager that multiplies its data within its wrapper function, provided that 4 is its initial data . context\\ Local :: new \"test_context\" ( \\ ctx_mgr cb -> ( cb ) * 2 ) 4","title":"Creating a new custom context manager"},{"location":"stdlib/context/local/#looking-up-a-value-in-the-local-context-dictionary","text":"Function lookup returns a value in the local context dictionary by the key (string), or () if not found.","title":"Looking up a value in the local context dictionary"},{"location":"stdlib/context/local/#checking-whether-a-key-is-present-in-the-local-context-dictionary","text":"Function contains returns true if the key (string) is present in the local context dictionary, or not.","title":"Checking whether a key is present in the local context dictionary"},{"location":"stdlib/context/local/#getting-the-default-name-of-the-context-manager","text":"Obtaining the name from the context manager tuple can be done using function get_name . It takes context manager tuple as its only argument and returns the name .","title":"Getting the default name of the context manager"},{"location":"stdlib/context/local/#getting-the-initialization-function-of-the-context-manager","text":"Obtaining the wrapper from the context manager tuple can be done using function get_wrapper . It takes context manager tuple as its only argument and returns the wrapper function.","title":"Getting the initialization function of the context manager"},{"location":"stdlib/context/local/#getting-the-data-of-the-managed-resource-of-the-context-manager","text":"Obtaining the data from the context manager tuple can be done using function get_data . It takes context manager tuple as its only argument and returns the data function. Using this context manager in a simple test program coul look like: with context \\ Local :: new \"test_context\" ( \\ ctx_mgr cb -> ( cb ) * 2 ) 4 as test_context # name : \"test_context\" # wrapper : \\ cm -> ( context \\ Local :: get_data cm ) * 2 # data : 4 let data = context \\ Local :: get_data test_context in data * 2 end","title":"Getting the data of the managed resource of the context manager"},{"location":"stdlib/functions/async/","text":"Function async executes a function asynchronously. It expects a lambda and this lambda will be computed asynchronously, thus not blocking the current thread. Result of this function is the result of the lambda provided as an argument. If async functions are nested, then the result of the whole expression is the result of the nested-most function. Usage: \u00b6 async ( \\-> IO :: println : hello )","title":"async"},{"location":"stdlib/functions/async/#usage","text":"async ( \\-> IO :: println : hello )","title":"Usage:"},{"location":"stdlib/functions/drop/","text":"Function drop executes a function asynchronously. It expects a lambda and this lambda will be computed asynchronously, thus not blocking the current thread. Unlike async , this function does not wait for the result of the computation and it returns immediately. The return value is () . Usage: \u00b6 drop ( \\-> IO :: println : hello ) This function is particalarly useful when writing server applications. In these situations it is not desirable to wait for the result of individual connection handlers, and it only needs to wait for the connection and return immediately, while hanndling the connection in the background. This functionality is similar to daemon context managers, see resource management for more details.","title":"drop"},{"location":"stdlib/functions/drop/#usage","text":"drop ( \\-> IO :: println : hello ) This function is particalarly useful when writing server applications. In these situations it is not desirable to wait for the result of individual connection handlers, and it only needs to wait for the connection and return immediately, while hanndling the connection in the background. This functionality is similar to daemon context managers, see resource management for more details.","title":"Usage:"},{"location":"stdlib/functions/eval/","text":"Function eval is used to dynamically evaluate a code. It takes two arguments, first is the symbol of a language, such as :yona , :js or :python and the second argument is a string of the expression to be evaluated in this language. Usage \u00b6 eval : yona \"5 + 5\"","title":"eval"},{"location":"stdlib/functions/eval/#usage","text":"eval : yona \"5 + 5\"","title":"Usage"},{"location":"stdlib/functions/float/","text":"Function float converts provided argument to a floating point number. Usage \u00b6 float \"5.0\" Supported data types : * byte * integer * float * string","title":"float"},{"location":"stdlib/functions/float/#usage","text":"float \"5.0\" Supported data types : * byte * integer * float * string","title":"Usage"},{"location":"stdlib/functions/identity/","text":"Function identity returns whatever value passed to it without any side-effects. Usage \u00b6 value = identity value","title":"identity"},{"location":"stdlib/functions/identity/#usage","text":"value = identity value","title":"Usage"},{"location":"stdlib/functions/infi/","text":"Function infi executes the provided zero-argument function infinite number of times. Usage \u00b6 infi ( \\-> IO :: println \"hello\" )","title":"infi"},{"location":"stdlib/functions/infi/#usage","text":"infi ( \\-> IO :: println \"hello\" )","title":"Usage"},{"location":"stdlib/functions/int/","text":"Function int converts provided argument to an integer number. Usage \u00b6 int \"5\" Supported data types : * byte * integer * float * string","title":"int"},{"location":"stdlib/functions/int/#usage","text":"int \"5\" Supported data types : * byte * integer * float * string","title":"Usage"},{"location":"stdlib/functions/never/","text":"Function never is a function that is never completed. Usage \u00b6 Because of Yona's non-blocking and asynchronous nature, it may not be obvious how to write a program that never completes. One common usecase here would be when writing an HTTP server, then a program should never stop. Since the HTTP server itself is a non-blocking function, after it is created, Yona program would just end, without using this function. Additionally, this function doesn't take any CPU time. do port = 3000 server = do double_handler = \\ params headers raw_body -> let { \"i\" = i } = JSON :: parse raw_body in ( 200 , { \"content-type\" = \"application/json\" }, JSON :: generate { \"result\" = 2 * i }) max_connections = 100 http \\ Server :: create \"127.0.0.1\" port max_connections |> http \\ Server :: handle \"/double\" iteration_handler |> http \\ Server :: start end never end","title":"never"},{"location":"stdlib/functions/never/#usage","text":"Because of Yona's non-blocking and asynchronous nature, it may not be obvious how to write a program that never completes. One common usecase here would be when writing an HTTP server, then a program should never stop. Since the HTTP server itself is a non-blocking function, after it is created, Yona program would just end, without using this function. Additionally, this function doesn't take any CPU time. do port = 3000 server = do double_handler = \\ params headers raw_body -> let { \"i\" = i } = JSON :: parse raw_body in ( 200 , { \"content-type\" = \"application/json\" }, JSON :: generate { \"result\" = 2 * i }) max_connections = 100 http \\ Server :: create \"127.0.0.1\" port max_connections |> http \\ Server :: handle \"/double\" iteration_handler |> http \\ Server :: start end never end","title":"Usage"},{"location":"stdlib/functions/ord/","text":"Function ord accepts character (must be an ASCII character, so less than 128) and returns a byte representing this character. Usage \u00b6 ord 'A' 65 b","title":"ord"},{"location":"stdlib/functions/ord/#usage","text":"ord 'A' 65 b","title":"Usage"},{"location":"stdlib/functions/sleep/","text":"Function sleep suspends executed by the required time. It requires one argument, a time tuple representing the duration for which the execution is suspended. Usage \u00b6 sleep ( : seconds , 5 )","title":"sleep"},{"location":"stdlib/functions/sleep/#usage","text":"sleep ( : seconds , 5 )","title":"Usage"},{"location":"stdlib/functions/str/","text":"Function str converts provided argument to its string representation. Any supported data type can be passed as an argument to this function. Usage \u00b6 str 5","title":"str"},{"location":"stdlib/functions/str/#usage","text":"str 5","title":"Usage"},{"location":"stdlib/functions/timeout/","text":"Function timeout will timeout an asynchronous computation after specified amount of time. It requires two arguments, a time tuple representing the duration for which the computation is allowed to run and asynchronous computation, which can be obtain by an async function for example. If the value is not computed in the specified timeout, a :timeout exception is raised. Usage \u00b6 timeout ( : seconds , 5 ) ( async \\-> : something ) It is recommended to always wrap a function passed as the second argument using async function, this way you can ensure that the function is being calculated asynchronously and the timeout can be applied.","title":"timeout"},{"location":"stdlib/functions/timeout/#usage","text":"timeout ( : seconds , 5 ) ( async \\-> : something ) It is recommended to always wrap a function passed as the second argument using async function, this way you can ensure that the function is being calculated asynchronously and the timeout can be applied.","title":"Usage"},{"location":"stdlib/functions/times/","text":"Function times executes the provided zero-argument function n number of times. Usage \u00b6 times 5 ( \\-> IO :: println \"hello\" ) Note : this function is typically called using the infix notation. 5 ` times ` ( \\-> IO :: println \"hello\" )","title":"times"},{"location":"stdlib/functions/times/#usage","text":"times 5 ( \\-> IO :: println \"hello\" ) Note : this function is typically called using the infix notation. 5 ` times ` ( \\-> IO :: println \"hello\" )","title":"Usage"},{"location":"stdlib/http/client/","text":"This module provides a simple HTTP Client built on top of java.net.http.HttpClient . Usage \u00b6 Function session creates HTTP session context manager. It takes a dictionary with optional settings, such as whether redirects should be followed or an HTTP authentication should be used. This session instance is then used to make HTTP requests. Example: with http \\ Client :: session {} as session # this will create a session without any additional configuration ( 200 , headers , body ) = http \\ Client :: get session \"https://httpbin.org/basic-auth/test/test\" {} end Another example: with http \\ Client :: session { : authenticator = ( : password , \"username\" , \"password\" ), : follow_redirects = : always } as session # this will initiate a new session , with additional ` authenticator ` and ` follow_redirects ` settings ... end Allowed options \u00b6 Function http\\Client::session accepts a dictionary of options and valid options are: authenticator , which is a triple, currently only password authentication is supported and the triple is of form (:password, \"username\", \"password\") follow_redirects , is one of: always : Always redirect never : Never redirect normal : Always redirect, except from HTTPS URLs to HTTP URLs. body_encoding , is either :binary , or :text (default option). When :binary is selected, the body is returned as a sequence of bytes, when :text is selected, the body is returned as a string Making HTTP requests \u00b6 This module provides following functions to make HTTP requests: ( status , headers , body ) = http \\ Client :: get session \"<url>\" {} # where the dictionary can be used to pass HTTP headers ( status , headers , body ) = http \\ Client :: delete session \"<url>\" {} # where the dictionary can be used to pass HTTP headers ( status , headers , body ) = http \\ Client :: post session \"<url>\" {} [] # where the dictionary can be used to pass HTTP headers , and the last argument is request body ( empty string in this case ) ( status , headers , body ) = http \\ Client :: put session \"<url>\" {} [] # where the dictionary can be used to pass HTTP headers , and the last argument is request body ( empty string in this case ) All these function require a session context manager, url string, a dictionary with HTTP headers and post and put also expect the request body as the last argument. The body can be either a sequence of bytes or a string. Authorizing a client request \u00b6 A complete example using HTTP authorization: with http \\ Client :: session { : authenticator = ( : password , \"test\" , \"test\" )} as session let ( 200 , headers , body ) = http \\ Client :: get session \"https://httpbin.org/basic-auth/test/test\" {} { \"user\" = user , \"authenticated\" = true } = JSON :: parse body in user end which uses httpbin testing service to test HTTP authentication. Passing HTTP headers in a request \u00b6 Another example to test request headers, using the same service: with http \\ Client :: session {} as session let ( 200 , headers , body ) = http \\ Client :: get session \"https://httpbin.org/headers\" { : accept = \"application/json\" } { \"headers\" = response_headers } = JSON :: parse body in Dict :: lookup response_headers \"Accept\" end","title":"http\\Client"},{"location":"stdlib/http/client/#usage","text":"Function session creates HTTP session context manager. It takes a dictionary with optional settings, such as whether redirects should be followed or an HTTP authentication should be used. This session instance is then used to make HTTP requests. Example: with http \\ Client :: session {} as session # this will create a session without any additional configuration ( 200 , headers , body ) = http \\ Client :: get session \"https://httpbin.org/basic-auth/test/test\" {} end Another example: with http \\ Client :: session { : authenticator = ( : password , \"username\" , \"password\" ), : follow_redirects = : always } as session # this will initiate a new session , with additional ` authenticator ` and ` follow_redirects ` settings ... end","title":"Usage"},{"location":"stdlib/http/client/#allowed-options","text":"Function http\\Client::session accepts a dictionary of options and valid options are: authenticator , which is a triple, currently only password authentication is supported and the triple is of form (:password, \"username\", \"password\") follow_redirects , is one of: always : Always redirect never : Never redirect normal : Always redirect, except from HTTPS URLs to HTTP URLs. body_encoding , is either :binary , or :text (default option). When :binary is selected, the body is returned as a sequence of bytes, when :text is selected, the body is returned as a string","title":"Allowed options"},{"location":"stdlib/http/client/#making-http-requests","text":"This module provides following functions to make HTTP requests: ( status , headers , body ) = http \\ Client :: get session \"<url>\" {} # where the dictionary can be used to pass HTTP headers ( status , headers , body ) = http \\ Client :: delete session \"<url>\" {} # where the dictionary can be used to pass HTTP headers ( status , headers , body ) = http \\ Client :: post session \"<url>\" {} [] # where the dictionary can be used to pass HTTP headers , and the last argument is request body ( empty string in this case ) ( status , headers , body ) = http \\ Client :: put session \"<url>\" {} [] # where the dictionary can be used to pass HTTP headers , and the last argument is request body ( empty string in this case ) All these function require a session context manager, url string, a dictionary with HTTP headers and post and put also expect the request body as the last argument. The body can be either a sequence of bytes or a string.","title":"Making HTTP requests"},{"location":"stdlib/http/client/#authorizing-a-client-request","text":"A complete example using HTTP authorization: with http \\ Client :: session { : authenticator = ( : password , \"test\" , \"test\" )} as session let ( 200 , headers , body ) = http \\ Client :: get session \"https://httpbin.org/basic-auth/test/test\" {} { \"user\" = user , \"authenticated\" = true } = JSON :: parse body in user end which uses httpbin testing service to test HTTP authentication.","title":"Authorizing a client request"},{"location":"stdlib/http/client/#passing-http-headers-in-a-request","text":"Another example to test request headers, using the same service: with http \\ Client :: session {} as session let ( 200 , headers , body ) = http \\ Client :: get session \"https://httpbin.org/headers\" { : accept = \"application/json\" } { \"headers\" = response_headers } = JSON :: parse body in Dict :: lookup response_headers \"Accept\" end","title":"Passing HTTP headers in a request"},{"location":"stdlib/http/server/","text":"This module provides a simple HTTP Server built on top of com.sun.net.httpserver.HttpServer . Usage \u00b6 To create a server instance, one must first instantiate it using: server = http \\ Server :: create bind_address port backlog Where the backlog is is the maximum number of queued incoming connections to allow on the listening socket. Queued TCP connections exceeding this limit may be rejected by the TCP implementation. If this value is less than or equal to zero, then a system default value is used. Handling a client request \u00b6 Once instantiated, the route handlers should be added to the server instance: server2 = http \\ Server :: handle \"/path\" : binary handler_function server Function handle expects the server path handled by the handler function, then it expects a body encoding symbol (either :binary or :text - default, utf-8 encoded), which is used to convert the client request body into either a sequence of bytes or a string, then the handler function as specified in the following part and the server object. Handler function is a function of three arguments, specifically connection params, request headers and request body: Connection params is a dictionary containing: * local_address * protocol * remote_address * method * uri Headers is a dictionary containing HTTP request headers and body is a sequence with the request body. The handler function returns a triple of response code, response headers and response body. Example handler function: handler = \\ params headers raw_body -> let { \"i\" = i } = JSON :: parse raw_body in ( 200 , { \"content-type\" = \"application/json\" }, JSON :: generate { \"result\" = i * 2 }) Note that an uncaught exception thrown in the handler function results in server responding with response code 500 and exception details in the body of the response. Wrapping it all up and starting a server \u00b6 Last function of this module is a function start which takes the server instance after all routes have been initialized and starts listening for connections. http\\ Server :: start server Using pipe operators, its possible to conveniently define server for example this way: max_connections = 100 server = http \\ Server :: create \"127.0.0.1\" port max_connections |> http \\ Server :: handle \"/path\" handler |> http \\ Server :: start A full example showing use of both HTTP server and client in an application for distributed PI computation can be seen in this test case .","title":"http\\Server"},{"location":"stdlib/http/server/#usage","text":"To create a server instance, one must first instantiate it using: server = http \\ Server :: create bind_address port backlog Where the backlog is is the maximum number of queued incoming connections to allow on the listening socket. Queued TCP connections exceeding this limit may be rejected by the TCP implementation. If this value is less than or equal to zero, then a system default value is used.","title":"Usage"},{"location":"stdlib/http/server/#handling-a-client-request","text":"Once instantiated, the route handlers should be added to the server instance: server2 = http \\ Server :: handle \"/path\" : binary handler_function server Function handle expects the server path handled by the handler function, then it expects a body encoding symbol (either :binary or :text - default, utf-8 encoded), which is used to convert the client request body into either a sequence of bytes or a string, then the handler function as specified in the following part and the server object. Handler function is a function of three arguments, specifically connection params, request headers and request body: Connection params is a dictionary containing: * local_address * protocol * remote_address * method * uri Headers is a dictionary containing HTTP request headers and body is a sequence with the request body. The handler function returns a triple of response code, response headers and response body. Example handler function: handler = \\ params headers raw_body -> let { \"i\" = i } = JSON :: parse raw_body in ( 200 , { \"content-type\" = \"application/json\" }, JSON :: generate { \"result\" = i * 2 }) Note that an uncaught exception thrown in the handler function results in server responding with response code 500 and exception details in the body of the response.","title":"Handling a client request"},{"location":"stdlib/http/server/#wrapping-it-all-up-and-starting-a-server","text":"Last function of this module is a function start which takes the server instance after all routes have been initialized and starts listening for connections. http\\ Server :: start server Using pipe operators, its possible to conveniently define server for example this way: max_connections = 100 server = http \\ Server :: create \"127.0.0.1\" port max_connections |> http \\ Server :: handle \"/path\" handler |> http \\ Server :: start A full example showing use of both HTTP server and client in an application for distributed PI computation can be seen in this test case .","title":"Wrapping it all up and starting a server"},{"location":"stdlib/java/types/","text":"This module provides some helper functions for interoperability with Java . Usage \u00b6 These are functions for converting Yona data types into Java types and should be used, when required as described in the polyglot page, automatic conversions section. Converting Yona integer to Java integer \u00b6 Function to_int takes Yona integer(64-bit) and converts it into Java integer(32-bit). If it doesn't fit, it raises a :badarg exception. Example: Java \\ Types :: to_int 5 Converting Yona float to Java float \u00b6 Function to_float takes Yona float(64-bit) and converts it into Java float(32-bit). If it doesn't fit, it raises a :badarg exception. Example: Java \\ Types :: to_float 5 f","title":"java\\Types"},{"location":"stdlib/java/types/#usage","text":"These are functions for converting Yona data types into Java types and should be used, when required as described in the polyglot page, automatic conversions section.","title":"Usage"},{"location":"stdlib/java/types/#converting-yona-integer-to-java-integer","text":"Function to_int takes Yona integer(64-bit) and converts it into Java integer(32-bit). If it doesn't fit, it raises a :badarg exception. Example: Java \\ Types :: to_int 5","title":"Converting Yona integer to Java integer"},{"location":"stdlib/java/types/#converting-yona-float-to-java-float","text":"Function to_float takes Yona float(64-bit) and converts it into Java float(32-bit). If it doesn't fit, it raises a :badarg exception. Example: Java \\ Types :: to_float 5 f","title":"Converting Yona float to Java float"},{"location":"stdlib/misc/timetuple/","text":"Duration in Yona is specified as a tuple, of a time unit symbol and a number representing the amount of that time unit. Available time unit symbols: :milli / :millis :second / :seconds :minute / :minutes :hour / :hours :day / :days :week / :weeks Constructing a tuple representing a duration is as simple as: ( : minutes , 5 ) which would represent a duration of 5 minutes.","title":"Duration specified as a tuple"},{"location":"stdlib/socket/tcp/client/","text":"This module provides non-blocking TCP client. Usage \u00b6 Use function connect to obtain a context manager that represents an estabilished TCP connection to the server. Use the [Connection] module from this package to perform read and write operations on this connection. Example: with socket \\ tcp \\ Client :: connect \"localhost\" 5555 as connection socket \\ tcp \\ Connection :: write connection \"hello\" end","title":"socket\\tcp\\Client"},{"location":"stdlib/socket/tcp/client/#usage","text":"Use function connect to obtain a context manager that represents an estabilished TCP connection to the server. Use the [Connection] module from this package to perform read and write operations on this connection. Example: with socket \\ tcp \\ Client :: connect \"localhost\" 5555 as connection socket \\ tcp \\ Connection :: write connection \"hello\" end","title":"Usage"},{"location":"stdlib/socket/tcp/connection/","text":"This module provides non-blocking functions for reading and writing on TCP connections. Connection can be estabilished either by the Client or Server module. Usage \u00b6 Reading from a connection \u00b6 Function read_until accepts a connection and a function of one argument, a byte, that returns a boolean representing whether to read more data from the socket or return whatever has been read so far. Example: socket\\ tcp \\ Connection :: read_until connection ( \\ b -> b != 10 b ) Reading a line from a connection \u00b6 Function read_line accepts a connection and returns a line of input delimited by a LF (ASCII 10) character. Example: socket\\ tcp \\ Connection :: read_line connection Writing to a connection \u00b6 Function write accepts a connection and a sequence of data (string - sequence of characters, or a sequence of bytes) to be sent to the other side on this connection. Example: socket\\ tcp \\ Connection :: write connection \"hello\"","title":"socket\\tcp\\Connection"},{"location":"stdlib/socket/tcp/connection/#usage","text":"","title":"Usage"},{"location":"stdlib/socket/tcp/connection/#reading-from-a-connection","text":"Function read_until accepts a connection and a function of one argument, a byte, that returns a boolean representing whether to read more data from the socket or return whatever has been read so far. Example: socket\\ tcp \\ Connection :: read_until connection ( \\ b -> b != 10 b )","title":"Reading from a connection"},{"location":"stdlib/socket/tcp/connection/#reading-a-line-from-a-connection","text":"Function read_line accepts a connection and returns a line of input delimited by a LF (ASCII 10) character. Example: socket\\ tcp \\ Connection :: read_line connection","title":"Reading a line from a connection"},{"location":"stdlib/socket/tcp/connection/#writing-to-a-connection","text":"Function write accepts a connection and a sequence of data (string - sequence of characters, or a sequence of bytes) to be sent to the other side on this connection. Example: socket\\ tcp \\ Connection :: write connection \"hello\"","title":"Writing to a connection"},{"location":"stdlib/socket/tcp/server/","text":"This module provides non-blocking TCP server. Usage \u00b6 This module provides functions for opening a TCP channel and accepting connections. Creating a TCP channel \u00b6 Function channel accepts a tuple of configuration arguments and returns a context manager representing this channel. The tuple format for a TCP channel is: (:tcp, address, port) where the address and port is the address and port to bind on. Example: with socket \\ tcp \\ Server :: channel ( : tcp , addr port ) as channel do IO :: println \"listening on {addr}:{port}\" infi ( \\-> accept channel ) end end Accepting a client connection \u00b6 Function accept requires a channel context and returns a context manager representing a connection as soon as it has been estabilished. Example: with daemon socket \\ tcp \\ Server :: accept channel as connection do socket \\ tcp \\ Connection :: write connection \"welcome: \" request = socket \\ Connection :: read_line connection |> Seq :: decode IO :: println request request |> socket \\ Connection :: write connection end end Tip Note the use of the daemon in the example above. In this way the handling of the client is not delaying the return of this with expression. This is a useful to handle multiple clients concurrently.","title":"socket\\tcp\\Server"},{"location":"stdlib/socket/tcp/server/#usage","text":"This module provides functions for opening a TCP channel and accepting connections.","title":"Usage"},{"location":"stdlib/socket/tcp/server/#creating-a-tcp-channel","text":"Function channel accepts a tuple of configuration arguments and returns a context manager representing this channel. The tuple format for a TCP channel is: (:tcp, address, port) where the address and port is the address and port to bind on. Example: with socket \\ tcp \\ Server :: channel ( : tcp , addr port ) as channel do IO :: println \"listening on {addr}:{port}\" infi ( \\-> accept channel ) end end","title":"Creating a TCP channel"},{"location":"stdlib/socket/tcp/server/#accepting-a-client-connection","text":"Function accept requires a channel context and returns a context manager representing a connection as soon as it has been estabilished. Example: with daemon socket \\ tcp \\ Server :: accept channel as connection do socket \\ tcp \\ Connection :: write connection \"welcome: \" request = socket \\ Connection :: read_line connection |> Seq :: decode IO :: println request request |> socket \\ Connection :: write connection end end Tip Note the use of the daemon in the example above. In this way the handling of the client is not delaying the return of this with expression. This is a useful to handle multiple clients concurrently.","title":"Accepting a client connection"},{"location":"stdlib/terminal/colors/","text":"This module contains basic terminal related functionality. Setting a terminal flag \u00b6 Function set accepts a type of a flag to set. Possible types are: :bold / :bright - synonyms :dim :underlined :blink :inverted - invert the foreground and background colors :hidden - useful for passwords Example: terminal\\ Colors :: set : bold Resetting a terminal flag \u00b6 Function reset resets flags set by function set . It accepts the same type of flags, with an additional option :all that resets all the flags.","title":"terminal\\Colors"},{"location":"stdlib/terminal/colors/#setting-a-terminal-flag","text":"Function set accepts a type of a flag to set. Possible types are: :bold / :bright - synonyms :dim :underlined :blink :inverted - invert the foreground and background colors :hidden - useful for passwords Example: terminal\\ Colors :: set : bold","title":"Setting a terminal flag"},{"location":"stdlib/terminal/colors/#resetting-a-terminal-flag","text":"Function reset resets flags set by function set . It accepts the same type of flags, with an additional option :all that resets all the flags.","title":"Resetting a terminal flag"},{"location":"stdlib/terminal/colors/background/","text":"This module provides background colors for terminal output. Functions provided in this module: default black light_gray dark_gray red light_red green light_green yellow light_yellow blue light_blue magenta cyan light_cyan white","title":"terminal\\colors\\Background"},{"location":"stdlib/terminal/colors/foreground/","text":"This module provides foreground colors for terminal output. Functions provided in this module: default black light_gray dark_gray red light_red green light_green yellow light_yellow blue light_blue magenta cyan light_cyan white","title":"terminal\\colors\\Foreground"}]}